// Generated using `moon info`, DON'T EDIT IT
package "Kaida-Amethyst/mbtcc/parser"

import(
  "Kaida-Amethyst/either"
  "Kaida-Amethyst/mbtcc/env"
  "Kaida-Amethyst/mbtcc/lexer"
)

// Values
fn format_lines(Iter[StringView], head_with? : String, continue_with? : String) -> String

fn next_check_point(ArrayView[@lexer.Token]) -> ArrayView[@lexer.Token]

// Errors
pub suberror ParseError {
  ParseError(@lexer.Token, String)
}

// Types and methods
pub struct AddiExpr {
  kind : AddiExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn AddiExpr::eval_as_int(Self) -> Int raise ParseError
fn AddiExpr::is_constant(Self) -> Bool
fn AddiExpr::to_string(Self, color? : Bool) -> String
impl Eq for AddiExpr
impl Show for AddiExpr

pub enum AddiExprKind {
  MultiExpr(MultiExpr)
  AddExpr(AddiExpr, MultiExpr)
  SubExpr(AddiExpr, MultiExpr)
}
impl Eq for AddiExprKind

pub struct AndExpr {
  kind : AndExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn AndExpr::eval_as_int(Self) -> Int raise ParseError
fn AndExpr::is_constant(Self) -> Bool
fn AndExpr::to_string(Self, color? : Bool) -> String
impl Eq for AndExpr
impl Show for AndExpr

pub enum AndExprKind {
  EqualityExpr(EqualityExpr)
  AndExpr(AndExpr, EqualityExpr)
}
impl Eq for AndExprKind

pub struct AssignExpr {
  kind : AssignExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn AssignExpr::eval_as_int(Self) -> Int raise ParseError
fn AssignExpr::is_constant(Self) -> Bool
fn AssignExpr::to_string(Self, color? : Bool) -> String
impl Eq for AssignExpr
impl Show for AssignExpr

pub enum AssignExprKind {
  Conditional(ConditionalExpr)
  Assign(UnaryExpr, AssignOp, AssignExpr)
}
impl Eq for AssignExprKind

pub(all) enum AssignOp {
  Assign
  MulAssign
  DivAssign
  ModAssign
  AddAssign
  SubAssign
  ShlAssign
  ShrAssign
  AndAssign
  XorAssign
  OrAssign
}
impl Eq for AssignOp

#alias(TypeName)
pub(all) struct CType {
  dataKind : CTypeDataKind
  is_const : Bool
  is_volatile : Bool
  is_restrict : Bool
  is_atomic : Bool
  tokens : ArrayView[@lexer.Token]
}
fn CType::additive_result_type(Self, Self, String) -> Self?
fn CType::char() -> Self
fn CType::common_type(Self, Self) -> Self?
fn CType::const_with(CTypeDataKind) -> Self
fn CType::default_with(CTypeDataKind) -> Self
fn CType::double() -> Self
fn CType::float() -> Self
fn CType::get_field_ctype_by_dot_acc(Self, String) -> Self?
fn CType::get_field_ctype_by_ptr_acc(Self, String) -> Self?
fn CType::int() -> Self
fn CType::int16() -> Self
#alias(is_dec_ok)
fn CType::is_inc_ok(Self) -> Bool
fn CType::is_integral(Self) -> Bool
fn CType::is_numeric(Self) -> Bool
fn CType::is_scalar(Self) -> Bool
fn CType::long() -> Self
fn CType::longlong() -> Self
fn CType::ptr_to(Self) -> Self
fn CType::string() -> Self
fn CType::struct_type(String, Array[(String, Self)]) -> Self
fn CType::uchar() -> Self
fn CType::uint() -> Self
fn CType::uint16() -> Self
fn CType::ulong() -> Self
fn CType::ulonglong() -> Self
fn CType::void_() -> Self
impl Eq for CType
impl Show for CType

pub(all) enum CTypeDataKind {
  Void
  Char
  UChar
  Int16
  UInt16
  Int
  UInt
  Long
  ULong
  LongLong
  ULongLong
  Float
  Double
  LongDouble
  Struct(String, Array[(String, CType)])
  Union(String, Array[(String, CType)])
  Enum(String, Array[String])
  Ptr(CType)
  Array(CType, Int)
}
impl Eq for CTypeDataKind
impl Show for CTypeDataKind

pub struct CastExpr {
  kind : CastExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn CastExpr::eval_as_double(Self) -> Double raise ParseError
fn CastExpr::eval_as_int(Self) -> Int raise ParseError
fn CastExpr::is_constant(Self) -> Bool
fn CastExpr::to_string(Self, color? : Bool) -> String
impl Eq for CastExpr
impl Show for CastExpr

pub enum CastExprKind {
  UnaryExpr(UnaryExpr)
  CastTo(CType, CastExpr)
}
impl Eq for CastExprKind

pub struct ConditionalExpr {
  kind : ConditionalExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn ConditionalExpr::eval_as_int(Self) -> Int raise ParseError
fn ConditionalExpr::is_constant(Self) -> Bool
fn ConditionalExpr::to_string(Self, color? : Bool) -> String
impl Eq for ConditionalExpr
impl Show for ConditionalExpr

pub enum ConditionalExprKind {
  LogicalOrExpr(LogicalOrExpr)
  ConditionalExpr(LogicalOrExpr, Expr, ConditionalExpr)
}
impl Eq for ConditionalExprKind

pub struct Context {
  code : String
  source_file : String
  tokens : Array[@lexer.Token]
  defined : @env.Env[String, @either.Either[CType, CType]]
  errs : Array[ParseError]
}
fn Context::add_typedef(Self, String, CType) -> Unit
fn Context::add_var(Self, String, CType) -> Unit
fn Context::catch_err(Self, ParseError) -> Unit
fn Context::from_lexer(@lexer.Context) -> Self
fn Context::get_typename_ctype(Self, String) -> CType?
fn Context::get_var_ctype(Self, String) -> CType?
fn Context::is_keyword_or_type_name(Self, @lexer.Token) -> Bool
fn Context::is_type_name(Self, String) -> Bool
fn Context::is_var_name(Self, String) -> Bool
fn Context::new(code~ : String, source_file? : String) -> Self
fn Context::parse_addi_expr(Self, ArrayView[@lexer.Token]) -> (AddiExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_and_expr(Self, ArrayView[@lexer.Token]) -> (AndExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_assign_expr(Self, ArrayView[@lexer.Token]) -> (AssignExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_cast_expr(Self, ArrayView[@lexer.Token]) -> (CastExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_conditional_expr(Self, ArrayView[@lexer.Token]) -> (ConditionalExpr, ArrayView[@lexer.Token]) raise ParseError
#alias(parse_type_name)
fn Context::parse_ctype(Self, ArrayView[@lexer.Token]) -> (CType, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_equality_expr(Self, ArrayView[@lexer.Token]) -> (EqualityExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_exclusive_or_expr(Self, ArrayView[@lexer.Token]) -> (ExclusiveOrExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_expr(Self, ArrayView[@lexer.Token]) -> (Expr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_inclusive_or_expr(Self, ArrayView[@lexer.Token]) -> (InclusiveOrExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_logical_and_expr(Self, ArrayView[@lexer.Token]) -> (LogicalAndExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_logical_or_expr(Self, ArrayView[@lexer.Token]) -> (LogicalOrExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_multi_expr(Self, ArrayView[@lexer.Token]) -> (MultiExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_postfix_expr(Self, ArrayView[@lexer.Token]) -> (PostfixExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_prim_expr(Self, ArrayView[@lexer.Token]) -> (PrimExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_relational_expr(Self, ArrayView[@lexer.Token]) -> (RelationalExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_shift_expr(Self, ArrayView[@lexer.Token]) -> (ShiftExpr, ArrayView[@lexer.Token]) raise ParseError
fn Context::parse_unary_expr(Self, ArrayView[@lexer.Token]) -> (UnaryExpr, ArrayView[@lexer.Token]) raise ParseError

pub struct EqualityExpr {
  kind : EqualityExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn EqualityExpr::eval_as_int(Self) -> Int raise ParseError
fn EqualityExpr::is_constant(Self) -> Bool
fn EqualityExpr::to_string(Self, color? : Bool) -> String
impl Eq for EqualityExpr
impl Show for EqualityExpr

pub enum EqualityExprKind {
  RelationalExpr(RelationalExpr)
  EQExpr(EqualityExpr, RelationalExpr)
  NEExpr(EqualityExpr, RelationalExpr)
}
impl Eq for EqualityExprKind

pub struct ExclusiveOrExpr {
  kind : ExclusiveOrExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn ExclusiveOrExpr::eval_as_int(Self) -> Int raise ParseError
fn ExclusiveOrExpr::is_constant(Self) -> Bool
fn ExclusiveOrExpr::to_string(Self, color? : Bool) -> String
impl Eq for ExclusiveOrExpr
impl Show for ExclusiveOrExpr

pub enum ExclusiveOrExprKind {
  AndExpr(AndExpr)
  ExclusiveOrExpr(ExclusiveOrExpr, AndExpr)
}
impl Eq for ExclusiveOrExprKind

pub struct Expr {
  assign_exprs : Array[AssignExpr]
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn Expr::eval_as_int(Self) -> Int raise ParseError
fn Expr::is_constant(Self) -> Bool
fn Expr::to_string(Self, color? : Bool) -> String
impl Eq for Expr
impl Show for Expr

pub struct InclusiveOrExpr {
  kind : InclusiveOrExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn InclusiveOrExpr::eval_as_int(Self) -> Int raise ParseError
fn InclusiveOrExpr::is_constant(Self) -> Bool
fn InclusiveOrExpr::to_string(Self, color? : Bool) -> String
impl Eq for InclusiveOrExpr
impl Show for InclusiveOrExpr

pub enum InclusiveOrExprKind {
  ExclusiveOrExpr(ExclusiveOrExpr)
  InclusiveOrExpr(InclusiveOrExpr, ExclusiveOrExpr)
}
impl Eq for InclusiveOrExprKind

pub struct LogicalAndExpr {
  kind : LogicalAndExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn LogicalAndExpr::eval_as_int(Self) -> Int raise ParseError
fn LogicalAndExpr::is_constant(Self) -> Bool
fn LogicalAndExpr::to_string(Self, color? : Bool) -> String
impl Eq for LogicalAndExpr
impl Show for LogicalAndExpr

pub enum LogicalAndExprKind {
  InclusiveOrExpr(InclusiveOrExpr)
  LogicalAndExpr(LogicalAndExpr, InclusiveOrExpr)
}
impl Eq for LogicalAndExprKind

pub struct LogicalOrExpr {
  kind : LogicalOrExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn LogicalOrExpr::eval_as_int(Self) -> Int raise ParseError
fn LogicalOrExpr::is_constant(Self) -> Bool
fn LogicalOrExpr::to_string(Self, color? : Bool) -> String
impl Eq for LogicalOrExpr
impl Show for LogicalOrExpr

pub enum LogicalOrExprKind {
  LogicalAndExpr(LogicalAndExpr)
  LogicalOrExpr(LogicalOrExpr, LogicalAndExpr)
}
impl Eq for LogicalOrExprKind

pub struct MultiExpr {
  kind : MultiExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn MultiExpr::eval_as_int(Self) -> Int raise ParseError
fn MultiExpr::is_constant(Self) -> Bool
fn MultiExpr::to_string(Self, color? : Bool) -> String
impl Eq for MultiExpr
impl Show for MultiExpr

pub enum MultiExprKind {
  CastExpr(CastExpr)
  MulExpr(MultiExpr, CastExpr)
  DivExpr(MultiExpr, CastExpr)
  ModExpr(MultiExpr, CastExpr)
}
impl Eq for MultiExprKind

pub struct PostfixExpr {
  kind : PostfixExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn PostfixExpr::eval_as_double(Self) -> Double raise ParseError
fn PostfixExpr::eval_as_int(Self) -> Int raise ParseError
fn PostfixExpr::is_assignable(Self) -> Bool
fn PostfixExpr::is_constant(Self) -> Bool
fn PostfixExpr::to_string(Self, color? : Bool) -> String
impl Eq for PostfixExpr
impl Show for PostfixExpr

pub enum PostfixExprKind {
  PrimExpr(PrimExpr)
  MemberAccess(PostfixExpr, String)
  PtrMemberAccess(PostfixExpr, String)
  PostInc(PostfixExpr)
  PostDec(PostfixExpr)
}
impl Eq for PostfixExprKind

pub struct PrimExpr {
  kind : PrimExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn PrimExpr::eval_as_double(Self) -> Double raise ParseError
fn PrimExpr::eval_as_int(Self) -> Int raise ParseError
fn PrimExpr::is_assignable(Self) -> Bool
fn PrimExpr::is_constant(Self) -> Bool
fn PrimExpr::to_string(Self, color? : Bool) -> String
impl Eq for PrimExpr
impl Show for PrimExpr

pub enum PrimExprKind {
  Ident(String)
  Char(Char)
  Int(Int)
  Long(Int64)
  LongLong(Int64)
  UInt(UInt)
  ULong(UInt64)
  ULongLong(UInt64)
  Float(Float)
  Double(Double)
  Strings(Array[String])
}
impl Eq for PrimExprKind
impl Show for PrimExprKind

pub struct RelationalExpr {
  kind : RelationalExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn RelationalExpr::eval_as_int(Self) -> Int raise ParseError
fn RelationalExpr::is_constant(Self) -> Bool
fn RelationalExpr::to_string(Self, color? : Bool) -> String
impl Eq for RelationalExpr
impl Show for RelationalExpr

pub enum RelationalExprKind {
  ShiftExpr(ShiftExpr)
  LTExpr(RelationalExpr, ShiftExpr)
  GTExpr(RelationalExpr, ShiftExpr)
  LEExpr(RelationalExpr, ShiftExpr)
  GEExpr(RelationalExpr, ShiftExpr)
}
impl Eq for RelationalExprKind

pub struct ShiftExpr {
  kind : ShiftExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn ShiftExpr::eval_as_int(Self) -> Int raise ParseError
fn ShiftExpr::is_constant(Self) -> Bool
fn ShiftExpr::to_string(Self, color? : Bool) -> String
impl Eq for ShiftExpr
impl Show for ShiftExpr

pub enum ShiftExprKind {
  AddiExpr(AddiExpr)
  ShlExpr(ShiftExpr, AddiExpr)
  ShrExpr(ShiftExpr, AddiExpr)
}
impl Eq for ShiftExprKind

pub struct UnaryExpr {
  kind : UnaryExprKind
  ctype : CType
  tokens : ArrayView[@lexer.Token]
}
fn UnaryExpr::eval_as_double(Self) -> Double raise ParseError
fn UnaryExpr::eval_as_int(Self) -> Int raise ParseError
fn UnaryExpr::is_assignable(Self) -> Bool
fn UnaryExpr::is_constant(Self) -> Bool
fn UnaryExpr::to_string(Self, color? : Bool) -> String
impl Eq for UnaryExpr
impl Show for UnaryExpr

pub enum UnaryExprKind {
  PostfixExpr(PostfixExpr)
  PreInc(UnaryExpr)
  PreDec(UnaryExpr)
  AddrOf(UnaryExpr)
  Deref(UnaryExpr)
  Negate(UnaryExpr)
  BitNot(UnaryExpr)
  LogicalNot(UnaryExpr)
}
impl Eq for UnaryExprKind

// Type aliases

// Traits

