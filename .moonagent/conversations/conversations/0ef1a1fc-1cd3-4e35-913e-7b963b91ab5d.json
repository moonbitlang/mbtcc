{
  "created_at": 1754546920429,
  "description": "Interactive conversation",
  "id": "0ef1a1fc-1cd3-4e35-913e-7b963b91ab5d",
  "messages": [
    {
      "content": "{\"content\":\"当前的项目是做什么的？\",\"role\":\"user\"}",
      "id": "f31f83aa-811c-4a71-9ef2-3db32c81e098",
      "role": "user",
      "timestamp": 1754546935600
    },
    {
      "content": "{\"content\":\"<mode>act</mode>\\n\\n我来帮您查看当前项目的情况。让我先探索一下项目目录结构。\",\"role\":\"assistant\",\"tool_calls\":[{\"id\":\"toolu_vrtx_01XaG4Xr1J3my4Wu9VeNCcAQ\",\"index\":0,\"type\":\"function\",\"function\":{\"name\":\"list_files\",\"arguments\":\"{\\\"path\\\": \\\".\\\", \\\"depth\\\": 2}\"}}]}",
      "id": "a454f99d-29a0-4314-970e-76ee78e03a23",
      "role": "assistant",
      "timestamp": 1754546942179
    },
    {
      "content": "{\"content\":\".gitignore\\n.moonagent/\\n.moonagent/conversations/\\n.moonagent/conversations/backups/\\n.moonagent/conversations/config.json\\n.moonagent/conversations/conversations/\\n.moonagent/pastes/\\nLICENSE\\nREADME.md\\ncolor/\\ncolor/moon.pkg.json\\ncolor/print.mbt\\nmain/\\nmain/main.mbt\\nmain/moon.pkg.json\\nmoon.mod.json\\nparser/\\nparser/Context.mbt\\nparser/c.g4\\nparser/c11.g4\\nparser/ctype.mbt\\nparser/lexer.mbt\\nparser/moon.pkg.json\\nparser/parser.mbt\",\"name\":\"list_files\",\"role\":\"tool\",\"tool_call_id\":\"toolu_vrtx_01XaG4Xr1J3my4Wu9VeNCcAQ\"}",
      "id": "c75955e6-2ed1-4d0b-9a82-e4865e608a8e",
      "role": "tool",
      "timestamp": 1754546942190
    },
    {
      "content": "{\"content\":\"现在让我查看项目的模块配置文件来了解项目的基本信息：\",\"role\":\"assistant\",\"tool_calls\":[{\"id\":\"toolu_vrtx_01PnidigjkqTVoLq6rzpH7UJ\",\"index\":0,\"type\":\"function\",\"function\":{\"name\":\"read_file\",\"arguments\":\"{\\\"path\\\": \\\"moon.mod.json\\\"}\"}}]}",
      "id": "90df2b23-329c-45f6-80ea-2c20892385cf",
      "role": "assistant",
      "timestamp": 1754546946797
    },
    {
      "content": "{\"content\":\"{\\n  \\\"name\\\": \\\"Kaida-Amethyst/mbtcc\\\",\\n  \\\"version\\\": \\\"0.1.0\\\",\\n  \\\"readme\\\": \\\"README.md\\\",\\n  \\\"repository\\\": \\\"\\\",\\n  \\\"license\\\": \\\"Apache-2.0\\\",\\n  \\\"keywords\\\": [],\\n  \\\"description\\\": \\\"\\\",\\n  \\\"source\\\": \\\"\\\"\\n}\\n\",\"name\":\"read_file\",\"role\":\"tool\",\"tool_call_id\":\"toolu_vrtx_01PnidigjkqTVoLq6rzpH7UJ\"}",
      "id": "dbc23784-798b-4417-9571-e707ef62a33c",
      "role": "tool",
      "timestamp": 1754546946911
    },
    {
      "content": "{\"content\":\"让我查看README文件了解更多项目信息：\",\"role\":\"assistant\",\"tool_calls\":[{\"id\":\"toolu_vrtx_01BdBxfifXWJpFdDYbZC9C1N\",\"index\":0,\"type\":\"function\",\"function\":{\"name\":\"read_file\",\"arguments\":\"{\\\"path\\\": \\\"README.md\\\"}\"}}]}",
      "id": "7ced899e-44fb-4d88-bb2a-ae0485eb5038",
      "role": "assistant",
      "timestamp": 1754546951093
    },
    {
      "content": "{\"content\":\"# Kaida-Amethyst/mbtcc\\n\\nmbtcc是一个使用moonbit编写的c编译器，支持c11标准，错误恢复，warning等。目的是为了验证llvm.mbt的功能，以及为MoonLLVM项目提供前端实现。\\n\\n## RoadMap\\n\\n[x] 词法分析\\n[ ] 语法分析\\n[ ] 语义检查\\n[ ] 提供友好的错误提示\\n[ ] 预处理器实现\\n[ ] llvm代码生成 (llvm.mbt)\\n[ ] llvm代码生成 (MoonLLVM)\\n[ ] 调试器\\n[ ] 自举编译Moonbit生成的C后端\\n[ ] 编译复杂大型项目，lua，sqlite等。\\n[ ] 尝试将mbtcc替代掉moonbit的tcc编译器\\n\\n\",\"name\":\"read_file\",\"role\":\"tool\",\"tool_call_id\":\"toolu_vrtx_01BdBxfifXWJpFdDYbZC9C1N\"}",
      "id": "53256c86-191d-404c-9fa5-75c594da5e8c",
      "role": "tool",
      "timestamp": 1754546951191
    },
    {
      "content": "{\"content\":\"现在让我看看main包的实现：\",\"role\":\"assistant\",\"tool_calls\":[{\"id\":\"toolu_vrtx_01UUXPjt8yBTZ1Gh4cVUwaBy\",\"index\":0,\"type\":\"function\",\"function\":{\"name\":\"read_file\",\"arguments\":\"{\\\"path\\\": \\\"main/main.mbt\\\"}\"}}]}",
      "id": "b89e9e32-0a2e-4165-a779-8f9a87f585b1",
      "role": "assistant",
      "timestamp": 1754546955371
    },
    {
      "content": "{\"content\":\"fn main {\\n  let code = \\n    #|int main() {\\n    #|  int a, b= 3;\\n    #|  a = fact(b);\\n    #|  printf(\\\"%d\\\\n\\\", a;\\n    #|  return 0;\\n    #|}\\n\\n  let ctx = @parser.Context::create(code)\\n  ctx.tokenize() catch {\\n    err => println(err)\\n  }\\n  \\n  ctx.parse() catch {\\n    @parser.ParseError((idx, msg)) => {\\n      let msg = ctx.get_error_msg(idx, msg)\\n      println(msg)\\n    }\\n    _ => ()\\n  }\\n\\n  ctx.print_toks()\\n  ctx.print_ast()\\n}\\n\",\"name\":\"read_file\",\"role\":\"tool\",\"tool_call_id\":\"toolu_vrtx_01UUXPjt8yBTZ1Gh4cVUwaBy\"}",
      "id": "b7578246-e86e-474f-9372-b8702bdd5cf6",
      "role": "tool",
      "timestamp": 1754546955469
    },
    {
      "content": "{\"content\":\"让我检查parser包的实现来更好地理解项目：\",\"role\":\"assistant\",\"tool_calls\":[{\"id\":\"toolu_vrtx_01BtgudCuWzrtDfqM1ZA94RX\",\"index\":0,\"type\":\"function\",\"function\":{\"name\":\"read_file\",\"arguments\":\"{\\\"path\\\": \\\"parser/parser.mbt\\\", \\\"query\\\": \\\"项目的主要功能和实现\\\"}\"}}]}",
      "id": "22ae87d6-2673-4969-b9cb-fa02ea1b8290",
      "role": "assistant",
      "timestamp": 1754546960162
    },
    {
      "content": "{\"content\":\"pub suberror ParseError(Int, String) derive(Show, Eq)\\n\\n//primaryExpression\\n//    : Identifier\\n//    | Constant\\n//    | StringLiteral+\\n//    | '(' expression ')'\\n//    | genericSelection\\n//    | '__extension__'? '(' compoundStatement ')' // Blocks (GCC extension)\\n//    | '__builtin_va_arg' '(' unaryExpression ',' typeName ')'\\n//    | '__builtin_offsetof' '(' typeName ',' unaryExpression ')'\\n//    ;\\npub enum PrimExpr {\\n  Identifier(String)\\n  Constant(Constant)\\n  StringLiteral(String)\\n  ParenExpr(Expr)\\n  //GenericSelection\\n} derive(Show, Eq)\\n\\nfn PrimExpr::parse(toks: ArrayView[Token], ctx: Context) -> (PrimExpr, ArrayView[Token]) raise {\\n  match toks {\\n    [Identifier(name), .. rest_toks] if !ctx.typedefs.contains(name) => {\\n      (PrimExpr::Identifier(name), rest_toks)\\n    }\\n    [Identifier(name), ..] => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Identifier \\\\{name} is a type, cannot be used as a primary expression\\\"))\\n    }\\n    [Constant(constant), .. rest_toks] => {\\n      (PrimExpr::Constant(constant), rest_toks)\\n    }\\n    [StringLiteral(lit), .. rest_toks] => {\\n      let mut str = lit\\n      let rest_toks = loop rest_toks {\\n        [StringLiteral(next_lit), .. next_rest] => {\\n          str += next_lit\\n          continue next_rest\\n        }\\n        rest_toks => break rest_toks\\n      }\\n      (PrimExpr::StringLiteral(str), rest_toks)\\n    }\\n    [LParen, .. rest_toks] => {\\n      let (expr, rest) = Expr::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after expression\\\"))\\n      }\\n      (PrimExpr::ParenExpr(expr), rest_toks)\\n    }\\n    curr_toks => {\\n      let idx = ctx.alltoks.length() - curr_toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Expected Identifier, Constant, StringLiteral, or '(' expression ')', but found \\\\{curr_toks[0]}\\\"))\\n    }\\n  }\\n}\\n\\ntest \\\"PrimExpr Parsing Test\\\" {\\n  let code_expect_rest : Map[String, (PrimExpr, ArrayView[Token])] = {\\n    \\\"abc + \\\" : (PrimExpr::Identifier(\\\"abc\\\"), [Plus, EOF]),\\n    \\\"123 - \\\" : (PrimExpr::Constant(Constant::Int(123)), [Minus, EOF]),\\n    \\\"\\\\\\\"hello \\\\\\\" \\\\\\\"world\\\\\\\" \\\": (PrimExpr::StringLiteral(\\\"hello world\\\"), [EOF]),\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let (expect_prim, expect_rest_toks) = expect_rest\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (prim, rest_toks) = PrimExpr::parse(toks, ctx);\\n    assert_eq(prim, expect_prim)\\n    assert_eq(rest_toks, expect_rest_toks)\\n  }\\n\\n  let code_expect_rest : Map[String, ArrayView[Token]] = {\\n    \\\"(abc + 123) - 456\\\" : [Minus, Constant(Constant::Int(456)), EOF],\\n    \\\"(a + b) * c\\\" : [Star, Identifier(\\\"c\\\"), EOF],\\n  }\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = PrimExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\ntest \\\"PrimExpr Parsing Negative Test\\\" {\\n  let code = \\\"MyInt + 1\\\"\\n  let ctx = Context::create(code)\\n  ctx.tokenize()\\n  let toks = ctx.alltoks\\n  assert_true((try? PrimExpr::parse(toks, ctx)) is Ok(_))\\n\\n  ctx.typedefs.set(\\\"MyInt\\\", 1)\\n  assert_true((try? PrimExpr::parse(toks, ctx)) is Err(ParseError((0, _))))\\n\\n  let code = \\\"(a + 1 ;\\\"\\n  let ctx = Context::create(code)\\n  ctx.tokenize()\\n  let toks = ctx.alltoks\\n  assert_true((try? PrimExpr::parse(toks, ctx)) is Err(ParseError((4, _))))\\n\\n  let code = \\\" ++ 3 \\\"\\n  let ctx = Context::create(code)\\n  ctx.tokenize()\\n  let toks = ctx.alltoks\\n  assert_true((try? PrimExpr::parse(toks, ctx)) is Err(ParseError((0, _))))\\n}\\n\\n//postfixExpression\\n//    : (primaryExpression | '__extension__'? '(' typeName ')' '{' initializerList ','? '}') (\\n//        '[' expression ']'\\n//        | '(' argumentExpressionList? ')'\\n//        | ('.' | '->') Identifier\\n//        | '++'\\n//        | '--'\\n//    )*\\n//    ;\\npub struct PostFixExpr {\\n  prim: PrimExpr\\n  suffixes: Array[PostFixSuffix]\\n} derive(Show, Eq)\\n\\nfn PostFixExpr::parse(toks: ArrayView[Token], ctx: Context) -> (PostFixExpr, ArrayView[Token]) raise {\\n  let (prim, rest_toks) = PrimExpr::parse(toks, ctx);\\n  let (suffixes, rest_toks) = PostFixSuffix::parse(rest_toks, ctx);\\n  let post_fix_expr = PostFixExpr::{\\n    prim,\\n    suffixes\\n  }\\n  (post_fix_expr, rest_toks)\\n}\\n\\npub enum PostFixSuffix {\\n  Indexing(Expr)\\n  Call(Array[AssignExpr])\\n  DotAccess(String)\\n  ArrowAccess(String)\\n  PlusPlus\\n  MinusMinus\\n} derive(Show, Eq)\\n\\nfn PostFixSuffix::parse(toks: ArrayView[Token], ctx: Context) -> (Array[PostFixSuffix], ArrayView[Token]) raise {\\n  let suffixes: Array[PostFixSuffix] = Array::new()\\n  let rest_toks = loop toks {\\n    [PlusPlus, .. rest_toks] => {\\n      suffixes.push(PostFixSuffix::PlusPlus)\\n      continue rest_toks\\n    }\\n    [MinusMinus, .. rest_toks] => {\\n      suffixes.push(PostFixSuffix::MinusMinus)\\n      continue rest_toks\\n    }\\n    [Dot, Identifier(name), .. rest_toks] => {\\n      suffixes.push(PostFixSuffix::DotAccess(name))\\n      continue rest_toks\\n    }\\n    [Arrow, Identifier(name), .. rest_toks] => {\\n      suffixes.push(PostFixSuffix::ArrowAccess(name))\\n      continue rest_toks\\n    }\\n    [LBracket, .. rest_toks] => {\\n      let (expr, rest) = Expr::parse(rest_toks, ctx);\\n      guard rest is [RBracket, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing bracket after expression\\\"))\\n      }\\n      suffixes.push(PostFixSuffix::Indexing(expr))\\n      continue rest_toks\\n    }\\n    [LParen, .. rest_toks] => {\\n      let (expr, rest) = Expr::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after argument expression list\\\"))\\n      }\\n      let args = expr.exprs\\n      suffixes.push(PostFixSuffix::Call(args))\\n      continue rest_toks\\n    }\\n    toks => {\\n      break toks // No more postfix suffixes\\n    }\\n  }\\n  (suffixes, rest_toks)\\n}\\n\\ntest \\\"PostfixExpr Parsing Test\\\" {\\n  let code_expect_rest : Map[String, ArrayView[Token]] = {\\n    \\\"abc++ + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n    \\\"abc-- + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n    \\\"point.x * 9\\\" : [Star, Constant(Constant::Int(9)), EOF],\\n    \\\"p->x / 3\\\" : [Slash, Constant(Constant::Int(3)), EOF],\\n    \\\"fact(42) * 7\\\" : [Star, Constant(Constant::Int(7)), EOF],\\n    \\\"printf(\\\\\\\"The number is %d\\\\\\\", 42);\\\" : [Semi, EOF],\\n    \\\"mat[0][i]++;\\\": [Semi, EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = PostFixExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//unaryExpression\\n//    : ('++' | '--' | 'sizeof')* (\\n//        postfixExpression\\n//        | unaryOperator castExpression\\n//        | ('sizeof' | '_Alignof') '(' typeName ')'\\n//        | '&&' Identifier // GCC extension address of label\\n//    )\\n//    ;\\npub struct UnaryExpr {\\n  prifix: Array[UnaryPrefix]\\n  body: UnaryExprBody\\n} derive(Show, Eq)\\n\\nfn UnaryExpr::parse(toks: ArrayView[Token], ctx: Context) -> (UnaryExpr, ArrayView[Token]) raise {\\n  let (prefixes, rest_toks) = UnaryPrefix::parse(toks, ctx);\\n  let (body, rest_toks) = UnaryExprBody::parse(rest_toks, ctx);\\n  let unary_expr = UnaryExpr::{\\n    prifix: prefixes,\\n    body\\n  }\\n  (unary_expr, rest_toks)\\n}\\n\\npub enum UnaryPrefix {\\n  PlusPlus\\n  MinusMinus\\n  Sizeof\\n} derive(Show, Eq)\\n\\nfn UnaryPrefix::parse(toks: ArrayView[Token], ctx: Context) -> (Array[UnaryPrefix], ArrayView[Token]) {\\n  let prefixes: Array[UnaryPrefix] = Array::new()\\n  let rest_toks = loop toks {\\n    [PlusPlus, .. rest_toks] => {\\n      prefixes.push(UnaryPrefix::PlusPlus)\\n      continue rest_toks\\n    }\\n    [MinusMinus, .. rest_toks] => {\\n      prefixes.push(UnaryPrefix::MinusMinus)\\n      continue rest_toks\\n    }\\n    // if `sizeof(` check it if it is `sizeof(typename)`, if so, need to break\\n    [Sizeof, LParen, .. rest_toks] as toks => {\\n      match (try? TypeName::parse(rest_toks, ctx)) {\\n        Err(_) => {\\n          prefixes.push(UnaryPrefix::Sizeof)\\n          continue toks[1:]\\n        }\\n        Ok(_) => break toks\\n      }\\n    }\\n    [Sizeof, .. rest_toks] => {\\n      prefixes.push(UnaryPrefix::Sizeof)\\n      continue rest_toks\\n    }\\n    toks => break toks // No more unary prefixes\\n  }\\n  (prefixes, rest_toks)\\n}\\n\\npub enum UnaryOperator {\\n  AddressOf  // &\\n  Dereference // *\\n  Positive    // +\\n  Negative    // -\\n  LogicalNot  // !\\n  BitwiseNot  // ~\\n} derive(Show, Eq)\\n\\npub enum UnaryExprBody {\\n  PostFix(PostFixExpr)\\n  UnaryOp(UnaryOperator, CastExpr)\\n  SizeofTypeName(TypeName)\\n  AlignOfTypeName(TypeName)\\n} derive(Show, Eq)\\n\\nfn UnaryExprBody::parse(toks: ArrayView[Token], ctx: Context) -> (UnaryExprBody, ArrayView[Token]) raise {\\n  match toks {\\n    [And | Star | Plus | Minus | Not | Tilde as sym, .. rest_toks] => {\\n      let (cast_expr, rest_toks) = CastExpr::parse(rest_toks, ctx);\\n      let unary_op = match sym {\\n        And => AddressOf\\n        Star => Dereference\\n        Plus => Positive\\n        Minus => Negative\\n        Not => LogicalNot\\n        _ => BitwiseNot // Tilde\\n      }\\n      (UnaryExprBody::UnaryOp(unary_op, cast_expr), rest_toks)\\n    }\\n    [Sizeof, LParen, .. rest_toks] => {\\n      let (type_name, rest) = TypeName::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after type name in sizeof\\\"))\\n      }\\n      (UnaryExprBody::SizeofTypeName(type_name), rest_toks)\\n    }\\n    [Alignof, LParen, .. rest_toks] => {\\n      let (type_name, rest) = TypeName::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after type name in _Alignof\\\"))\\n      }\\n      (UnaryExprBody::AlignOfTypeName(type_name), rest_toks)\\n    }\\n    toks => {\\n      let (post_fix_expr, rest_toks) = PostFixExpr::parse(toks, ctx);\\n      (UnaryExprBody::PostFix(post_fix_expr), rest_toks)\\n    }\\n  }\\n}\\n\\ntest \\\"UnaryExpr Parsing Test\\\" {\\n\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"++abc + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n    \\\"--abc + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n    \\\"sizeof(int) + 1\\\" : [Plus, Constant(Constant::Int(1)), EOF],\\n    \\\"_Alignof(int) + 2\\\" : [Plus, Constant(Constant::Int(2)), EOF],\\n    \\\"&abc + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n    \\\"*abc + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n    \\\"+abc + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n    \\\"-abc + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n    \\\"!abc + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n    \\\"~abc + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n    \\\"++mat[i][j];\\\" : [Semi, EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = UnaryExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//castExpression\\n//    : '__extension__'? '(' typeName ')' castExpression\\n//    | unaryExpression\\n//    | DigitSequence // for\\n//    ;\\ntype CastExpr (Array[TypeName], UnaryExpr) derive(Show, Eq)\\n\\nfn CastExpr::parse(toks: ArrayView[Token], ctx: Context) -> (CastExpr, ArrayView[Token]) raise {\\n  let cast_types: Array[TypeName] = Array::new()\\n  loop toks {\\n    [LParen, .. rest_toks] => {\\n      let (type_name, rest) = TypeName::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after type name in cast\\\"))\\n      }\\n      cast_types.push(type_name)\\n      continue rest\\n    }\\n    toks => {\\n      let (unary_expr, rest_toks) = UnaryExpr::parse(toks, ctx);\\n      (CastExpr((cast_types, unary_expr)), rest_toks)\\n    }\\n  }\\n}\\n\\ntest \\\"CastExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"(int)abc + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n    \\\"(int)(float)abc + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n    \\\"(int)123 + b\\\" : [Plus, Identifier(\\\"b\\\"), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = CastExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//multiplicativeExpression\\n//    : castExpression (('*' | '/' | '%') castExpression)*\\n//    ;\\npub struct MultExpr {\\n  exprs: Array[CastExpr]\\n  ops: Array[MultOp]\\n} derive(Show, Eq)\\n\\npub enum MultOp {\\n  Mult // *\\n  Div // /\\n  Mod // %\\n} derive(Show, Eq)\\n\\nfn MultExpr::parse(toks: ArrayView[Token], ctx: Context) -> (MultExpr, ArrayView[Token]) raise {\\n  let exprs: Array[CastExpr] = Array::new()\\n  let ops: Array[MultOp] = Array::new()\\n  let (first_expr, rest_toks) = CastExpr::parse(toks, ctx);\\n  exprs.push(first_expr)\\n  let rest_toks = loop rest_toks {\\n    [Star, .. rest_toks] => {\\n      ops.push(MultOp::Mult)\\n      let (next_expr, rest) = CastExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    [Slash, .. rest_toks] => {\\n      ops.push(MultOp::Div)\\n      let (next_expr, rest) = CastExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    [Mod, .. rest_toks] => {\\n      ops.push(MultOp::Mod)\\n      let (next_expr, rest) = CastExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    toks => break toks\\n  }\\n  let mult_expr = MultExpr::{ exprs, ops }\\n  (mult_expr, rest_toks)\\n}\\n\\ntest \\\"MultExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"abc * b + bbcc\\\" : [Plus, Identifier(\\\"bbcc\\\"), EOF],\\n    \\\"abc / b + a123\\\" : [Plus, Identifier(\\\"a123\\\"), EOF],\\n    \\\"abc % b - u89\\\" : [Minus, Identifier(\\\"u89\\\"), EOF],\\n    \\\"123 * 456 + 789\\\" : [Plus, Constant(Constant::Int(789)), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = MultExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//additiveExpression\\n//    : multiplicativeExpression (('+' | '-') multiplicativeExpression)*\\n//    ;\\npub struct AddSubExpr {\\n  exprs: Array[MultExpr]\\n  ops: Array[AddSubOp]\\n} derive(Show, Eq)\\n\\npub enum AddSubOp {\\n  Add // +\\n  Sub // -\\n} derive(Show, Eq)\\n\\nfn AddSubExpr::parse(toks: ArrayView[Token], ctx: Context) -> (AddSubExpr, ArrayView[Token]) raise {\\n  let exprs: Array[MultExpr] = Array::new()\\n  let ops: Array[AddSubOp] = Array::new()\\n  let (first_expr, rest_toks) = MultExpr::parse(toks, ctx);\\n  exprs.push(first_expr)\\n  let rest_toks = loop rest_toks {\\n    [Plus, .. rest_toks] => {\\n      ops.push(AddSubOp::Add)\\n      let (next_expr, rest) = MultExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    [Minus, .. rest_toks] => {\\n      ops.push(AddSubOp::Sub)\\n      let (next_expr, rest) = MultExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    toks => break toks\\n  }\\n  let add_sub_expr = AddSubExpr::{ exprs, ops }\\n  (add_sub_expr, rest_toks)\\n}\\n\\ntest \\\"AddSubExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"abc + b - c > 78\\\" : [GT, Constant(Constant::Int(78)), EOF],\\n    \\\"abc - b + d <= 96\\\" : [LE, Constant(Constant::Int(96)), EOF],\\n    \\\"123 + 456 - 789 == 12345\\\" : [EQ, Constant(Constant::Int(12345)), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = AddSubExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//shiftExpression\\n//    : additiveExpression (('<<' | '>>') additiveExpression)*\\n//    ;\\npub struct ShiftExpr {\\n  exprs: Array[AddSubExpr]\\n  ops: Array[ShiftOp]\\n} derive(Show, Eq)\\n\\npub enum ShiftOp {\\n  Shl // <<\\n  Shr // >>\\n} derive(Show, Eq)\\n\\nfn ShiftExpr::parse(toks: ArrayView[Token], ctx: Context) -> (ShiftExpr, ArrayView[Token]) raise {\\n  let exprs: Array[AddSubExpr] = Array::new()\\n  let ops: Array[ShiftOp] = Array::new()\\n  let (first_expr, rest_toks) = AddSubExpr::parse(toks, ctx);\\n  exprs.push(first_expr)\\n  let rest_toks = loop rest_toks {\\n    [Shl, .. rest_toks] => {\\n      ops.push(ShiftOp::Shl)\\n      let (next_expr, rest) = AddSubExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    [Shr, .. rest_toks] => {\\n      ops.push(ShiftOp::Shr)\\n      let (next_expr, rest) = AddSubExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    toks => break toks\\n  }\\n  let shift_expr = ShiftExpr::{ exprs, ops }\\n  (shift_expr, rest_toks)\\n}\\n\\ntest \\\"ShiftExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"a << 1 > 345 \\\" : [GT, Constant(Constant::Int(345)), EOF],\\n    \\\"b >> 2 < 456\\\" : [LT, Constant(Constant::Int(456)), EOF],\\n    \\\"c << 3 == 789\\\" : [EQ, Constant(Constant::Int(789)), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = ShiftExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//relationalExpression\\n//    : shiftExpression (('<' | '>' | '<=' | '>=') shiftExpression)*\\n//    ;\\npub struct RelationalExpr {\\n  exprs: Array[ShiftExpr]\\n  ops: Array[RelationalOp]\\n} derive(Show, Eq)\\n\\npub enum RelationalOp {\\n  LT // <\\n  GT // >\\n  LE // <=\\n  GE // >=\\n} derive(Show, Eq)\\n\\nfn RelationalExpr::parse(toks: ArrayView[Token], ctx: Context) -> (RelationalExpr, ArrayView[Token]) raise {\\n  let exprs: Array[ShiftExpr] = Array::new()\\n  let ops: Array[RelationalOp] = Array::new()\\n  let (first_expr, rest_toks) = ShiftExpr::parse(toks, ctx);\\n  exprs.push(first_expr)\\n  let rest_toks = loop rest_toks {\\n    [LT, .. rest_toks] => {\\n      ops.push(RelationalOp::LT)\\n      let (next_expr, rest) = ShiftExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    [GT, .. rest_toks] => {\\n      ops.push(RelationalOp::GT)\\n      let (next_expr, rest) = ShiftExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    [LE, .. rest_toks] => {\\n      ops.push(RelationalOp::LE)\\n      let (next_expr, rest) = ShiftExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    [GE, .. rest_toks] => {\\n      ops.push(RelationalOp::GE)\\n      let (next_expr, rest) = ShiftExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    toks => break toks\\n  }\\n  let relational_expr = RelationalExpr::{ exprs, ops }\\n  (relational_expr, rest_toks)\\n}\\n\\ntest \\\"RelationalExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"a < b + c && True\\\" : [DoubleAnd, Identifier(\\\"True\\\"), EOF],\\n    \\\"d > e - f || False\\\" : [DoubleOr, Identifier(\\\"False\\\"), EOF],\\n    \\\"g <= h * i && cond\\\" : [DoubleAnd, Identifier(\\\"cond\\\"), EOF],\\n    \\\"j >= k / l || cond\\\" : [DoubleOr, Identifier(\\\"cond\\\"), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = RelationalExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//equalityExpression\\n//    : relationalExpression (('==' | '!=') relationalExpression)*\\n//    ;\\npub struct EqualityExpr {\\n  exprs: Array[RelationalExpr]\\n  ops: Array[EqualityOp]\\n} derive(Show, Eq)\\n\\npub enum EqualityOp {\\n  EQ // ==\\n  NE // !=\\n} derive(Show, Eq)\\n\\nfn EqualityExpr::parse(toks: ArrayView[Token], ctx: Context) -> (EqualityExpr, ArrayView[Token]) raise {\\n  let exprs: Array[RelationalExpr] = Array::new()\\n  let ops: Array[EqualityOp] = Array::new()\\n  let (first_expr, rest_toks) = RelationalExpr::parse(toks, ctx);\\n  exprs.push(first_expr)\\n  let rest_toks = loop rest_toks {\\n    [EQ, .. rest_toks] => {\\n      ops.push(EqualityOp::EQ)\\n      let (next_expr, rest) = RelationalExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    [NE, .. rest_toks] => {\\n      ops.push(EqualityOp::NE)\\n      let (next_expr, rest) = RelationalExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    toks => break toks\\n  }\\n  let equality_expr = EqualityExpr::{ exprs, ops }\\n  (equality_expr, rest_toks)\\n}\\n\\ntest \\\"EqualityExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"a == b + c || True\\\" : [DoubleOr, Identifier(\\\"True\\\"), EOF],\\n    \\\"d != e - f && False\\\" : [DoubleAnd, Identifier(\\\"False\\\"), EOF],\\n    \\\"g == h * i || cond\\\" : [DoubleOr, Identifier(\\\"cond\\\"), EOF],\\n    \\\"j != k / l && cond\\\" : [DoubleAnd, Identifier(\\\"cond\\\"), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = EqualityExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//andExpression\\n//    : equalityExpression ('&' equalityExpression)*\\n//    ;\\npub struct AndExpr {\\n  exprs: Array[EqualityExpr]\\n} derive(Show, Eq)\\n\\nfn AndExpr::parse(toks: ArrayView[Token], ctx: Context) -> (AndExpr, ArrayView[Token]) raise {\\n  let exprs: Array[EqualityExpr] = Array::new()\\n  let (first_expr, rest_toks) = EqualityExpr::parse(toks, ctx);\\n  exprs.push(first_expr)\\n  let rest_toks = loop rest_toks {\\n    [And, .. rest_toks] => {\\n      let (next_expr, rest) = EqualityExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    toks => break toks\\n  }\\n  let and_expr = AndExpr::{ exprs }\\n  (and_expr, rest_toks)\\n}\\n\\ntest \\\"AndExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"a & b | c \\\" : [Or, Identifier(\\\"c\\\"), EOF],\\n    \\\"a & c ^ d\\\" : [Xor, Identifier(\\\"d\\\"), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = AndExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//exclusiveOrExpression\\n//    : andExpression ('^' andExpression)*\\n//    ;\\npub struct ExclusiveOrExpr {\\n  exprs: Array[AndExpr]\\n} derive(Show, Eq)\\n\\nfn ExclusiveOrExpr::parse(toks: ArrayView[Token], ctx: Context) -> (ExclusiveOrExpr, ArrayView[Token]) raise {\\n  let exprs: Array[AndExpr] = Array::new()\\n  let (first_expr, rest_toks) = AndExpr::parse(toks, ctx);\\n  exprs.push(first_expr)\\n  let rest_toks = loop rest_toks {\\n    [Xor, .. rest_toks] => {\\n      let (next_expr, rest) = AndExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    toks => break toks\\n  }\\n  let exclusive_or_expr = ExclusiveOrExpr::{ exprs }\\n  (exclusive_or_expr, rest_toks)\\n}\\n\\ntest \\\"ExclusiveOrExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"1 & a ^ b ? c\\\" : [Question, Identifier(\\\"c\\\"), EOF],\\n    \\\"d ^ e & 1 ? f\\\" : [Question, Identifier(\\\"f\\\"), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = ExclusiveOrExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//inclusiveOrExpression\\n//    : exclusiveOrExpression ('|' exclusiveOrExpression)*\\n//    ;\\npub struct InclusiveOrExpr {\\n  exprs: Array[ExclusiveOrExpr]\\n} derive(Show, Eq)\\n\\nfn InclusiveOrExpr::parse(toks: ArrayView[Token], ctx: Context) -> (InclusiveOrExpr, ArrayView[Token]) raise {\\n  let exprs: Array[ExclusiveOrExpr] = Array::new()\\n  let (first_expr, rest_toks) = ExclusiveOrExpr::parse(toks, ctx);\\n  exprs.push(first_expr)\\n  let rest_toks = loop rest_toks {\\n    [Or, .. rest_toks] => {\\n      let (next_expr, rest) = ExclusiveOrExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    toks => break toks\\n  }\\n  let inclusive_or_expr = InclusiveOrExpr::{ exprs }\\n  (inclusive_or_expr, rest_toks)\\n}\\n\\ntest \\\"InclusiveOrExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"a | b ? c\\\" : [Question, Identifier(\\\"c\\\"), EOF],\\n    \\\"d | e ? f\\\" : [Question, Identifier(\\\"f\\\"), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    //let toks = lex(code)\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = InclusiveOrExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//logicalAndExpression\\n//    : inclusiveOrExpression ('&&' inclusiveOrExpression)*\\n//    ;\\npub struct LogicalAndExpr {\\n  exprs: Array[InclusiveOrExpr]\\n} derive(Show, Eq)\\n\\nfn LogicalAndExpr::parse(toks: ArrayView[Token], ctx: Context) -> (LogicalAndExpr, ArrayView[Token]) raise {\\n  let exprs: Array[InclusiveOrExpr] = Array::new()\\n  let (first_expr, rest_toks) = InclusiveOrExpr::parse(toks, ctx);\\n  exprs.push(first_expr)\\n  let rest_toks = loop rest_toks {\\n    [DoubleAnd, .. rest_toks] => {\\n      let (next_expr, rest) = InclusiveOrExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    toks => break toks\\n  }\\n  let logical_and_expr = LogicalAndExpr::{ exprs }\\n  (logical_and_expr, rest_toks)\\n}\\n\\ntest \\\"LogicalAndExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"a && b || c\\\" : [DoubleOr, Identifier(\\\"c\\\"), EOF],\\n    \\\"d && e || f\\\" : [DoubleOr, Identifier(\\\"f\\\"), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = LogicalAndExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//logicalOrExpression\\n//    : logicalAndExpression ('||' logicalAndExpression)*\\n//    ;\\npub struct LogicalOrExpr {\\n  exprs: Array[LogicalAndExpr]\\n} derive(Show, Eq)\\n\\nfn LogicalOrExpr::parse(toks: ArrayView[Token], ctx: Context) -> (LogicalOrExpr, ArrayView[Token]) raise {\\n  let exprs: Array[LogicalAndExpr] = Array::new()\\n  let (first_expr, rest_toks) = LogicalAndExpr::parse(toks, ctx);\\n  exprs.push(first_expr)\\n  let rest_toks = loop rest_toks {\\n    [DoubleOr, .. rest_toks] => {\\n      let (next_expr, rest) = LogicalAndExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    toks => break toks\\n  }\\n  let logical_or_expr = LogicalOrExpr::{ exprs }\\n  (logical_or_expr, rest_toks)\\n}\\n\\ntest \\\"LogicalOrExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"a || b ? c\\\" : [Question, Identifier(\\\"c\\\"), EOF],\\n    \\\"d || e ? f\\\" : [Question, Identifier(\\\"f\\\"), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = LogicalOrExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//conditionalExpression\\n//    : logicalOrExpression ('?' expression ':' conditionalExpression)?\\n//    ;\\npub struct ConditionalExpr {\\n  expr: LogicalOrExpr\\n  select: (Expr, ConditionalExpr)?\\n} derive(Show, Eq)\\n\\nfn ConditionalExpr::parse(toks: ArrayView[Token], ctx: Context) -> (ConditionalExpr, ArrayView[Token]) raise {\\n  let (logical_or_expr, rest_toks) = LogicalOrExpr::parse(toks, ctx);\\n  match  rest_toks {\\n    [Question, .. rest_toks] => {\\n      let (expr, rest) = Expr::parse(rest_toks, ctx);\\n      guard rest is [Colon, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected ':' after expression in conditional expression\\\"))\\n      }\\n      let (conditional_expr, rest_toks) = ConditionalExpr::parse(rest_toks, ctx);\\n      let conditional_expr = ConditionalExpr::{\\n        expr: logical_or_expr,\\n        select: Some((expr, conditional_expr))\\n      }\\n      (conditional_expr, rest_toks)\\n    }\\n    _ => {\\n      let conditional_expr = ConditionalExpr::{\\n        expr: logical_or_expr,\\n        select: None\\n      }\\n      (conditional_expr, rest_toks)\\n    }\\n  }\\n}\\n\\ntest \\\"ConditionalExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"cond1 ? 123 : 456 ; int\\\" : [Semi, Int, EOF],\\n    \\\"cond1 && cond2 ? abc : def ; struct\\\" : [Semi, Struct, EOF],\\n    \\\"init || Next ? 7 : 8; \\\" : [Semi, EOF],\\n    \\\"a123 += 5\\\" : [PlusAssign, Constant(Constant::Int(5)), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = ConditionalExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n\\n//assignmentExpression\\n//    : conditionalExpression\\n//    | unaryExpression assignmentOperator assignmentExpression\\n//    | DigitSequence // for\\n//    ;\\npub enum AssignExpr {\\n  Conditional(ConditionalExpr)\\n  Assign(UnaryExpr, AssignOp, AssignExpr)\\n} derive(Show, Eq)\\n\\nfn AssignExpr::parse(toks: ArrayView[Token], ctx:Context) -> (AssignExpr, ArrayView[Token]) raise {\\n  let (unary_expr, rest_toks) = UnaryExpr::parse(toks, ctx);\\n  match rest_toks {\\n    [Assign | PlusAssign | MinusAssign | StarAssign | DivAssign | ModAssign |\\n     LeftShiftAssign | RightShiftAssign | AndAssign | BitXorAssign |\\n     BitOrAssign as op, .. rest_toks] => {\\n      let (assign_expr, rest_toks) = AssignExpr::parse(rest_toks, ctx);\\n      let assign_op = match op {\\n        Assign => AssignOp::Assign\\n        PlusAssign => AssignOp::AddAssign\\n        MinusAssign => AssignOp::SubAssign\\n        StarAssign => AssignOp::MultAssign\\n        DivAssign => AssignOp::DivAssign\\n        ModAssign => AssignOp::ModAssign\\n        AndAssign => AssignOp::AndAssign\\n        OrAssign => AssignOp::OrAssign\\n        LeftShiftAssign => AssignOp::LeftShiftAssign\\n        RightShiftAssign => AssignOp::RightShiftAssign\\n        BitAndAssign => AssignOp::BitwiseAndAssign\\n        BitXorAssign => AssignOp::BitwiseXorAssign\\n        _ => AssignOp::BitwiseOrAssign // BitOrAssign\\n      }\\n      (AssignExpr::Assign(unary_expr, assign_op, assign_expr), rest_toks)\\n    }\\n    _ => {\\n      let (cond_expr, rest_toks) = ConditionalExpr::parse(toks, ctx);\\n      (AssignExpr::Conditional(cond_expr), rest_toks)\\n    }\\n  }\\n}\\n\\ntest \\\"AssignExpr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"a = b + c; int\\\" : [Semi, Int, EOF],\\n    \\\"x += 5; union\\\" : [Semi, Union, EOF],\\n    \\\"cond1 && cond2 ? abc : def ; struct\\\" : [Semi, Struct, EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = AssignExpr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\npub enum AssignOp {\\n  Assign // =\\n  AddAssign // +=\\n  SubAssign // -=\\n  MultAssign // *=\\n  DivAssign // /=\\n  ModAssign // %=\\n  AndAssign // &&=\\n  OrAssign // ||=\\n  LeftShiftAssign // <<=\\n  RightShiftAssign // >>=\\n  BitwiseAndAssign // &=\\n  BitwiseXorAssign // ^=\\n  BitwiseOrAssign // |=\\n} derive(Show, Eq)\\n\\n//expression\\n//    : assignmentExpression (',' assignmentExpression)*\\n//    ;\\npub struct Expr {\\n  exprs: Array[AssignExpr]\\n} derive(Show, Eq)\\n\\nfn Expr::parse(toks: ArrayView[Token], ctx: Context) -> (Expr, ArrayView[Token]) raise {\\n  let exprs: Array[AssignExpr] = Array::new()\\n  let (first_expr, rest_toks) = AssignExpr::parse(toks, ctx);\\n  exprs.push(first_expr)\\n  let rest_toks = loop rest_toks {\\n    [Comma, .. rest_toks] => {\\n      let (next_expr, rest) = AssignExpr::parse(rest_toks, ctx);\\n      exprs.push(next_expr)\\n      continue rest\\n    }\\n    toks => break toks\\n  }\\n  let expr = Expr::{ exprs }\\n  (expr, rest_toks)\\n}\\n\\ntest \\\"Expr Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"a = b + c, d = e - f; int\\\" : [Semi, Int, EOF],\\n    \\\"x += 5, y -= 10; union\\\" : [Semi, Union, EOF],\\n    \\\"cond1 && cond2 ? abc : def ; struct\\\" : [Semi, Struct, EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = Expr::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\ntypealias ConditionalExpr as ConstantExpr\\n\\n//declaration\\n//    : declarationSpecifiers initDeclaratorList? ';'\\n//    | staticAssertDeclaration\\n//    ;\\npub enum Declaration {\\n  Decl(Array[DeclSpec], Array[InitDeclarator])\\n  //StaticAssertDecl(StaticAssertDecl)\\n} derive(Show, Eq)\\n\\nfn Declaration::parse(toks: ArrayView[Token], ctx: Context) -> (Declaration, ArrayView[Token]) raise {\\n  let is_typedef = toks is [Typedef, ..]\\n  let (decl_specs, rest_toks) = DeclSpecList::parse(toks, ctx);\\n  let decl_specs = decl_specs.inner()\\n  guard !decl_specs.is_empty() else {\\n    let idx = ctx.alltoks.length() - rest_toks.length()\\n    raise ParseError((idx, \\\"Parse Error: Declaration specifiers cannot be empty\\\"))\\n  }\\n  let (declaration, rest_toks) = match rest_toks {\\n    [Semi, .. rest_toks] => {\\n      let declaration = Declaration::Decl(decl_specs, Array::new())\\n      (declaration, rest_toks)\\n    }\\n    _ => {\\n      let (init_decls, rest_toks) = InitDeclaratorList::parse(rest_toks, ctx);\\n      let declaration = Declaration::Decl(decl_specs, init_decls.inner())\\n      (declaration, rest_toks)\\n    }\\n  }\\n  if is_typedef {\\n    let inits = match declaration {\\n      Declaration::Decl(_, inits) => inits\\n      //_ => raise ParseError(\\\"Expected declaration in typedef\\\")\\n    }\\n    inits.each(i => ctx.add_typedef(i.get_ident()))\\n  }\\n  (declaration, rest_toks)\\n}\\n\\ntest \\\"Declaration Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"int a;\\\" : [Semi, EOF],\\n    \\\"const char *p;\\\" : [Semi, EOF],\\n    \\\"static int x = 10;\\\" : [Semi, EOF],\\n    \\\"extern void func(int, int);\\\" : [Semi, EOF],\\n    \\\"typedef int MyInt;\\\" : [Semi, EOF],\\n    \\\"struct Point { int x; int y; };\\\" : [EOF],\\n    \\\"typedef struct { int a; int b; } MyStruct;\\\" : [Semi, EOF],\\n    \\\"typedef double *p, *const q;\\\" : [Semi, EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = Declaration::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\npub enum DeclSpec {\\n  StorageClassSpec(StorageClassSpec)\\n  TypeSpec(TypeSpec)\\n  TypeQualifier(TypeQualifier)\\n  FunctionSpec(FunctionSpec)\\n  AlignmentSpec(AlignmentSpec)\\n} derive(Show, Eq)\\n\\nfn DeclSpec::parse(toks: ArrayView[Token], ctx: Context) -> (DeclSpec, ArrayView[Token]) raise {\\n  match toks {\\n    [Auto | Register | Static | ThreadLocal | Extern | Typedef, ..] => {\\n      let (storage_class_spec, rest_toks) = StorageClassSpec::parse(toks, ctx);\\n      (DeclSpec::StorageClassSpec(storage_class_spec), rest_toks)\\n    }\\n    [Const | Volatile | Restrict | Atomic, ..] => {\\n      let (type_qualifier, rest_toks) = TypeQualifier::parse(toks, ctx);\\n      (DeclSpec::TypeQualifier(type_qualifier), rest_toks)\\n    }\\n    [Inline, Noreturn, ..] => {\\n      let (function_spec, rest_toks) = FunctionSpec::parse(toks, ctx);\\n      (DeclSpec::FunctionSpec(function_spec), rest_toks)\\n    }\\n    [Alignas, ..] => {\\n      let (alignment_spec, rest_toks) = AlignmentSpec::parse(toks, ctx);\\n      (DeclSpec::AlignmentSpec(alignment_spec), rest_toks)\\n    }\\n    _ => {\\n      let (type_spec, rest_toks) = TypeSpec::parse(toks, ctx);\\n      (DeclSpec::TypeSpec(type_spec), rest_toks)\\n    }\\n  }\\n}\\n\\npriv type DeclSpecList Array[DeclSpec]\\n\\nfn DeclSpecList::parse(toks: ArrayView[Token], ctx: Context) -> (DeclSpecList, ArrayView[Token]) {\\n  let decl_specs: Array[DeclSpec] = Array::new()\\n  let mut rest_toks = toks\\n  while (try? DeclSpec::parse(rest_toks, ctx)) is Ok((decl_spec, rest)) {\\n    decl_specs.push(decl_spec)\\n    rest_toks = rest\\n    // If we encounter a TypeSpec, we can stop parsing further decl specs\\n    if decl_spec is TypeSpec(_) {\\n      break\\n    }\\n  }\\n  (decl_specs, rest_toks)\\n}\\n\\ntest \\\"DeclSpecList Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"int a;\\\" : [Identifier(\\\"a\\\"), Semi, EOF],\\n    \\\"const char *p;\\\" : [Star, Identifier(\\\"p\\\"), Semi, EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = DeclSpecList::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\npub enum StorageClassSpec {\\n  Auto // auto\\n  Register // register\\n  Static // static\\n  ThreadLocal // _Thread_local\\n  Extern // extern\\n  Typedef // typedef\\n} derive(Show, Eq)\\n\\nfn StorageClassSpec::parse(toks: ArrayView[Token], ctx: Context) -> (StorageClassSpec, ArrayView[Token]) raise {\\n  match toks {\\n    [Auto, .. rest_toks] => (StorageClassSpec::Auto, rest_toks)\\n    [Register, .. rest_toks] => (StorageClassSpec::Register, rest_toks)\\n    [Static, .. rest_toks] => (StorageClassSpec::Static, rest_toks)\\n    [ThreadLocal, .. rest_toks] => (StorageClassSpec::ThreadLocal, rest_toks)\\n    [Extern, .. rest_toks] => (StorageClassSpec::Extern, rest_toks)\\n    [Typedef, .. rest_toks] => (StorageClassSpec::Typedef, rest_toks)\\n    _ => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented storage class specifier\\\"))\\n    }\\n  }\\n}\\n\\n//typeSpecifier\\n//    : 'void'\\n//    | 'char'\\n//    | 'short'\\n//    | 'int'\\n//    | 'long'\\n//    | 'float'\\n//    | 'double'\\n//    | 'signed'\\n//    | 'unsigned'\\n//    | '_Bool'\\n//    | '_Complex'\\n//    | '__m128'\\n//    | '__m128d'\\n//    | '__m128i'\\n//    | '__extension__' '(' ('__m128' | '__m128d' | '__m128i') ')'\\n//    | atomicTypeSpecifier\\n//    | structOrUnionSpecifier\\n//    | enumSpecifier\\n//    | typedefName\\n//    | '__typeof__' '(' constantExpression ')' // GCC extension\\n//    ;\\npub enum TypeSpec {\\n  Void // void\\n  Char // char\\n  Short // short\\n  Int // int\\n  Long // long\\n  Float // float\\n  Double // double\\n  Signed // signed\\n  Unsigned // unsigned\\n  Bool // _Bool\\n  Complex // _Complex\\n  Atomic(TypeName) // _Atomic(type)\\n  StructSpec(StructSpec)\\n  UnionSpec(UnionSpec)\\n  EnumSpec(EnumSpec)\\n  TypedefName(String)\\n} derive(Show, Eq)\\n\\nfn TypeSpec::parse(toks: ArrayView[Token], ctx: Context) -> (TypeSpec, ArrayView[Token]) raise {\\n  match toks {\\n    [Void, .. rest_toks] => (TypeSpec::Void, rest_toks)\\n    [Char, .. rest_toks] => (TypeSpec::Char, rest_toks)\\n    [Short, .. rest_toks] => (TypeSpec::Short, rest_toks)\\n    [Int, .. rest_toks] => (TypeSpec::Int, rest_toks)\\n    [Long, .. rest_toks] => (TypeSpec::Long, rest_toks)\\n    [Float, .. rest_toks] => (TypeSpec::Float, rest_toks)\\n    [Double, .. rest_toks] => (TypeSpec::Double, rest_toks)\\n    [Signed, .. rest_toks] => (TypeSpec::Signed, rest_toks)\\n    [Unsigned, .. rest_toks] => (TypeSpec::Unsigned, rest_toks)\\n    [Bool, .. rest_toks] => (TypeSpec::Bool, rest_toks)\\n    [Complex, .. rest_toks] => (TypeSpec::Complex, rest_toks)\\n    [Atomic, LParen, .. rest_toks] => {\\n      let (type_name, rest) = TypeName::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after type name in _Atomic\\\"))\\n      }\\n      (TypeSpec::Atomic(type_name), rest)\\n    }\\n    [Struct, .. ] as toks => {\\n      let (struct_spec, rest_toks) = StructSpec::parse(toks, ctx);\\n      (TypeSpec::StructSpec(struct_spec), rest_toks)\\n    }\\n    [Union, .. ] as toks => {\\n      let (union_spec, rest_toks) = UnionSpec::parse(toks, ctx);\\n      (TypeSpec::UnionSpec(union_spec), rest_toks)\\n    }\\n    [Enum, ..] as toks => {\\n      let (enum_spec, rest_toks) = EnumSpec::parse(toks, ctx);\\n      (TypeSpec::EnumSpec(enum_spec), rest_toks)\\n    }\\n    [Identifier(name), .. rest_toks] if ctx.typedefs.contains(name) => (TypeSpec::TypedefName(name), rest_toks)\\n    toks => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Parse TypeSpec Error, unexpect token \\\\{toks[0]}\\\"))\\n    }\\n  }\\n}\\n\\n//enum AtomTypeSpec {\\n//  Void\\n//  Char\\n//  Bool\\n//  Short\\n//  Int\\n//  Long\\n//  Float\\n//  Double\\n//  Signed\\n//  Unsigned\\n//} derive(Hash, Eq, Show)\\n//\\n//fn convert_typespec_list_to_type(type_specs: Array[TypeSpec]) -> Type {\\n//  // if type_specs is [StructSpec(_), ..t] {\\n//  //   if !t.is_empty() { panic() }\\n//  //   ...\\n//  // }\\n//  // if type_specs is [UnionSpec(_), ..t] {\\n//  //  if !t.is_empty() { panic() }\\n//  //  ...\\n//  //  }\\n//  let atom_type_specs: Set[AtomTypeSpec] = Set::new()\\n//  for tyspec in type_specs {\\n//    let atype_spec = match tyspec {\\n//      TypeSpec::Void => AtomTypeSpec::Void\\n//      TypeSpec::Char => AtomTypeSpec::Char\\n//      TypeSpec::Bool => AtomTypeSpec::Bool\\n//      TypeSpec::Short => AtomTypeSpec::Short\\n//      TypeSpec::Int => AtomTypeSpec::Int\\n//      TypeSpec::Long => AtomTypeSpec::Long\\n//      TypeSpec::Float => AtomTypeSpec::Float\\n//      TypeSpec::Double => AtomTypeSpec::Double\\n//      TypeSpec::Signed => AtomTypeSpec::Signed\\n//      TypeSpec::Unsigned => AtomTypeSpec::Unsigned\\n//      _ => {\\n//        panic()\\n//      }\\n//    }\\n//    atom_type_specs.add(atype_spec)\\n//  }\\n//  let atom_type_specs = atom_type_specs.to_array()\\n//  match atom_type_specs {\\n//    [Void] => Type::Void\\n//    [Char] => Type::Int8\\n//    [Bool] => Type::Bool\\n//    [Short] => Type::Int16\\n//    [Int | Signed] => Type::Int32\\n//    [Long] => Type::Int64\\n//    [Float] => Type::Float\\n//    [Double] => Type::Double\\n//    [Unsigned] => Type::UInt32\\n//    [Char, Unsigned] => Type::UInt8\\n//    [Short, Unsigned] => Type::UInt16\\n//    [Long, Unsigned] => Type::UInt64\\n//    [Int, Unsigned] => Type::UInt32\\n//    [Int, Long] => Type::Int64\\n//    [Long, Long] => Type::Int64\\n//    [Int, Long, Long] => Type::Int64\\n//    [Int, Long, Signed] => Type::Int64\\n//    [Long, Long, Signed] => Type::Int64\\n//    [Int, Long, Long, Signed] => Type::Int64\\n//    [Int, Long, Unsigned] => Type::UInt64\\n//    [Long, Long, Unsigned] => Type::UInt64\\n//    [Int, Unsigned, Long, Long] => Type::UInt64\\n//    [Double, Long] => Type::Double\\n//    _ => {\\n//      println(\\\"Fatal Error: Unimplemented type combination: \\\\{atom_type_specs}\\\")\\n//      panic()\\n//    }\\n//  }\\n//}\\n\\npub enum TypeQualifier {\\n  Const // const\\n  Volatile // volatile\\n  Restrict // restrict\\n  Atomic // _Atomic\\n} derive(Show, Eq)\\n\\nfn TypeQualifier::parse(toks: ArrayView[Token], ctx: Context) -> (TypeQualifier, ArrayView[Token]) raise {\\n  match toks {\\n    [Const, .. rest_toks] => (TypeQualifier::Const, rest_toks)\\n    [Volatile, .. rest_toks] => (TypeQualifier::Volatile, rest_toks)\\n    [Restrict, .. rest_toks] => (TypeQualifier::Restrict, rest_toks)\\n    [Atomic, .. rest_toks] => (TypeQualifier::Atomic, rest_toks)\\n    _ => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented type qualifier\\\"))\\n    }\\n  }\\n}\\n\\ntype TypeQualifierList Array[TypeQualifier] derive(Show, Eq)\\n\\nfn TypeQualifierList::parse(toks: ArrayView[Token]) -> (TypeQualifierList, ArrayView[Token]) {\\n  let qualifiers: Array[TypeQualifier] = Array::new()\\n  let rest_toks = loop toks {\\n    [Const, .. rest_toks] => {\\n      qualifiers.push(TypeQualifier::Const)\\n      continue rest_toks\\n    }\\n    [Volatile, .. rest_toks] => {\\n      qualifiers.push(TypeQualifier::Volatile)\\n      continue rest_toks\\n    }\\n    [Restrict, .. rest_toks] => {\\n      qualifiers.push(TypeQualifier::Restrict)\\n      continue rest_toks\\n    }\\n    [Atomic, .. rest_toks] => {\\n      qualifiers.push(TypeQualifier::Atomic)\\n      continue rest_toks\\n    }\\n    toks => break toks // no more type qualifiers\\n  }\\n  (TypeQualifierList(qualifiers), rest_toks)\\n}\\n\\n//fn TypeQualifierList::is_empty(self: Self) -> Bool {\\n//  self.inner().is_empty()\\n//}\\n\\npub enum TypeSpecOrQualifier {\\n  TypeSpec(TypeSpec)\\n  TypeQualifier(TypeQualifier)\\n} derive(Show, Eq)\\n\\nfn TypeSpecOrQualifier::parse(toks: ArrayView[Token], ctx: Context) -> (TypeSpecOrQualifier, ArrayView[Token]) raise {\\n  match toks {\\n    [Const, .. rest_toks] => (TypeSpecOrQualifier::TypeQualifier(TypeQualifier::Const), rest_toks)\\n    [Volatile, .. rest_toks] => (TypeSpecOrQualifier::TypeQualifier(TypeQualifier::Volatile), rest_toks)\\n    [Restrict, .. rest_toks] => (TypeSpecOrQualifier::TypeQualifier(TypeQualifier::Restrict), rest_toks)\\n    [Atomic, .. rest_toks] => (TypeSpecOrQualifier::TypeQualifier(TypeQualifier::Atomic), rest_toks)\\n    _ => {\\n      let (type_spec, rest) = TypeSpec::parse(toks, ctx);\\n      (TypeSpecOrQualifier::TypeSpec(type_spec), rest)\\n    }\\n  }\\n}\\n\\npriv type TypeSpecOrQualifierList Array[TypeSpecOrQualifier]\\n\\nfn TypeSpecOrQualifierList::parse(toks: ArrayView[Token], ctx: Context) -> (TypeSpecOrQualifierList, ArrayView[Token]) {\\n  let specs: Array[TypeSpecOrQualifier] = Array::new()\\n  let mut toks = toks\\n  while (try? TypeSpecOrQualifier::parse(toks, ctx)) is Ok((spec, rest)) {\\n    specs.push(spec)\\n    toks = rest\\n    // If we encounter a TypeSpec, we can stop parsing further type specifiers\\n    if spec is TypeSpec(_) {\\n      break\\n    }\\n  }\\n  (TypeSpecOrQualifierList(specs), toks)\\n}\\n\\npub struct StructSpec {\\n  name: String?\\n  decls: Array[StructDeclaration]\\n} derive(Show, Eq)\\n\\nfn StructSpec::parse(toks: ArrayView[Token], ctx: Context) -> (StructSpec, ArrayView[Token]) raise {\\n  guard toks is [Struct, .. toks] else {\\n    let idx = ctx.alltoks.length() - toks.length()\\n    raise ParseError((idx, \\\"Parse Error: Expected 'struct' keyword for struct specification\\\"))\\n  }\\n\\n  let (name, rest_toks) = match toks {\\n    [Identifier(name), LBrace, .. rest_toks] => (Some(name), rest_toks)\\n    [LBrace, .. rest_toks] => (None, rest_toks) // No name specified\\n    _ => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Expected identifier or '{' after 'struct'\\\"))\\n    }\\n  }\\n\\n  let decls : Array[StructDeclaration] = Array::new()\\n\\n  let rest_toks = loop rest_toks {\\n    [RBrace, ..rest_toks] => {\\n      break rest_toks\\n    }\\n    [Semi, .. rest_toks] => {\\n      // Empty declaration, just skip it\\n      continue rest_toks\\n    }\\n    rest_toks => {\\n      let (struct_decl, rest_toks) = StructDeclaration::parse(rest_toks, ctx);\\n      decls.push(struct_decl);\\n      continue rest_toks\\n    }\\n  }\\n  let struct_spec = StructSpec::{ name, decls };\\n  (struct_spec, rest_toks)\\n}\\n\\ntest \\\"StructSpec Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"struct MyStruct { int a; double b; }\\\" : [EOF],\\n    \\\"struct { char c; }\\\" : [EOF],\\n    \\\"struct EmptyStruct {}\\\" : [EOF],\\n    \\\"struct AnotherStruct { int x; }\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = StructSpec::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\npub struct UnionSpec {\\n  name: String?\\n  decls: Array[StructDeclaration]\\n} derive(Show, Eq)\\n\\nfn UnionSpec::parse(toks: ArrayView[Token], ctx: Context) -> (UnionSpec, ArrayView[Token]) raise {\\n  guard toks is [Union, .. toks] else {\\n    let idx = ctx.alltoks.length() - toks.length()\\n    raise ParseError((idx, \\\"Parse Error: Expected 'union' keyword for union specification\\\"))\\n  }\\n\\n  let (name, rest_toks) = match toks {\\n    [Identifier(name), LBrace, .. rest_toks] => (Some(name), rest_toks)\\n    [LBrace, .. rest_toks] => (None, rest_toks) // No name specified\\n    _ => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Expected identifier or '{' after 'union'\\\"))\\n    }\\n  }\\n\\n  let decls : Array[StructDeclaration] = Array::new()\\n\\n  let rest_toks = loop rest_toks {\\n    [RBrace, ..rest_toks] => {\\n      break rest_toks\\n    }\\n    [Semi, .. rest_toks] => {\\n      // Empty declaration, just skip it\\n      continue rest_toks\\n    }\\n    rest_toks => {\\n      let (struct_decl, rest_toks) = StructDeclaration::parse(rest_toks, ctx);\\n      decls.push(struct_decl);\\n      continue rest_toks\\n    }\\n  }\\n  let union_spec = UnionSpec::{ name, decls };\\n  (union_spec, rest_toks)\\n}\\n\\ntest \\\"UnionSpec Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"union MyUnion { int a; double b; }\\\" : [EOF],\\n    \\\"union { char c; }\\\" : [EOF],\\n    \\\"union EmptyUnion {}\\\" : [EOF],\\n    \\\"union AnotherUnion { int x; }\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = UnionSpec::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//structDeclaration // The first two rules have priority order and cannot be simplified to one expression.\\n//    : specifierQualifierList structDeclaratorList ';'\\n//    | specifierQualifierList ';'\\n//    | staticAssertDeclaration\\n//    ;\\npub enum StructDeclaration {\\n  Normal(Array[TypeSpecOrQualifier], Array[StructDeclarator])\\n  //StaticAssertDecl(StaticAssertDecl)\\n} derive(Show, Eq)\\n\\nfn StructDeclaration::parse(toks: ArrayView[Token], ctx: Context) -> (StructDeclaration, ArrayView[Token]) raise {\\n  let (type_spec_or_qualifiers, rest_toks) = TypeSpecOrQualifierList::parse(toks, ctx);\\n  let type_spec_or_qualifiers = type_spec_or_qualifiers.inner()\\n\\n  if rest_toks is [Semi, .. rest_toks] {\\n    // Case: specifierQualifierList ';'\\n    return (StructDeclaration::Normal(type_spec_or_qualifiers, Array::new()), rest_toks)\\n  }\\n\\n  let (struct_declarators, rest_toks) = StructDeclaratorList::parse(rest_toks, ctx);\\n  (StructDeclaration::Normal(type_spec_or_qualifiers, struct_declarators.inner()), rest_toks)\\n}\\n\\ntest \\\"StructDeclaration Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"int a, b;\\\" : [Semi, EOF],\\n    \\\"double x;\\\" : [Semi, EOF],\\n    \\\"int a : 1, b : 2;\\\" : [Semi, EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = StructDeclaration::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\npub enum StructDeclarator {\\n  Declarator(Declarator)\\n  Field(Declarator?, ConstantExpr)\\n} derive(Show, Eq)\\n\\n//structDeclarator\\n//    : declarator\\n//    | declarator? ':' constantExpression\\n//    ;\\nfn StructDeclarator::parse(toks: ArrayView[Token], ctx: Context) -> (StructDeclarator, ArrayView[Token]) raise {\\n  if toks is [Colon, ..rest_toks] {\\n    let (const_expr, rest_toks) = ConstantExpr::parse(rest_toks, ctx);\\n    return (StructDeclarator::Field(None, const_expr), rest_toks)\\n  }\\n\\n  let (declarator, rest_toks) = Declarator::parse(toks, ctx);\\n  match rest_toks {\\n    [Colon, .. rest_toks] => {\\n      let (const_expr, rest_toks) = ConstantExpr::parse(rest_toks, ctx);\\n      (StructDeclarator::Field(Some(declarator), const_expr), rest_toks)\\n    }\\n    _ => (StructDeclarator::Declarator(declarator), rest_toks)\\n  }\\n}\\n\\npriv type StructDeclaratorList Array[StructDeclarator]\\n\\nfn StructDeclaratorList::parse(toks: ArrayView[Token], ctx: Context) -> (StructDeclaratorList, ArrayView[Token]) raise {\\n  let decls: Array[StructDeclarator] = Array::new()\\n  let (first_decl, rest_toks) = StructDeclarator::parse(toks, ctx);\\n  decls.push(first_decl)\\n  let rest_toks = loop rest_toks {\\n    [Comma, .. rest_toks] => {\\n      let (next_decl, rest) = StructDeclarator::parse(rest_toks, ctx);\\n      decls.push(next_decl)\\n      continue rest\\n    }\\n    toks => break toks // no more struct declarators\\n  }\\n  (StructDeclaratorList(decls), rest_toks)\\n}\\n\\ntest \\\"StructDeclaratorList Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"a ;\\\" : [Semi, EOF],\\n    \\\"a, b ;\\\" : [Semi, EOF],\\n    \\\"a : 1, b : 2 ;\\\" : [Semi, EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = StructDeclaratorList::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\npub struct Declarator {\\n  pointer: Pointer?\\n  directDeclarator: DirectDeclarator\\n} derive(Show, Eq)\\n\\nfn Declarator::get_ident(self: Self) -> String {\\n  self.directDeclarator.get_ident()\\n}\\n\\nfn Declarator::parse(toks: ArrayView[Token], ctx: Context) -> (Declarator, ArrayView[Token]) raise {\\n  let (pointer, rest_toks) = Pointer::parse(toks);\\n  let pointer = if pointer.inner().is_empty() {\\n    None // No pointer qualifiers\\n  } else {\\n    Some(pointer)\\n  }\\n  let (direct_declarator, rest_toks) = DirectDeclarator::parse(rest_toks, ctx);\\n  (Declarator::{ pointer, directDeclarator: direct_declarator }, rest_toks)\\n}\\n\\ntest \\\"Declarator Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"a\\\" : [EOF],\\n    \\\"*b\\\" : [EOF],\\n    \\\"**c\\\" : [EOF],\\n    \\\"* const Point\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = Declarator::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//pointer\\n//    : (('*' | '^') typeQualifierList?)+ // ^ - Blocks language extension\\n//    ;\\ntype Pointer Array[TypeQualifier?]  derive(Show, Eq)\\n\\nfn Pointer::parse(toks: ArrayView[Token]) -> (Pointer, ArrayView[Token]) {\\n  let qualifiers: Array[TypeQualifier?] = Array::new()\\n  let rest_toks = loop toks {\\n    [Star, Const, ..rest_toks] => {\\n      qualifiers.push(Some(Const))\\n      continue rest_toks\\n    }\\n    [Star, Volatile, ..rest_toks] => {\\n      qualifiers.push(Some(Volatile))\\n      continue rest_toks\\n    }\\n    [Star, Restrict, ..rest_toks] => {\\n      qualifiers.push(Some(Restrict))\\n      continue rest_toks\\n    }\\n    [Star, Atomic, ..rest_toks] => {\\n      qualifiers.push(Some(Atomic))\\n      continue rest_toks\\n    }\\n    [Star, .. rest_toks] => {\\n      qualifiers.push(None) // Pointer without type qualifier\\n      continue rest_toks\\n    }\\n    toks => break toks // no more pointers\\n  }\\n  (Pointer(qualifiers), rest_toks)\\n}\\n\\ntest \\\"Pointer Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"*a\\\": [Identifier(\\\"a\\\"), EOF],\\n    \\\"**b\\\": [Identifier(\\\"b\\\"), EOF],\\n    \\\"* const Point\\\": [Identifier(\\\"Point\\\"), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = Pointer::parse(toks);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n\\n//directDeclarator\\n//    : Identifier\\n//    | '(' declarator ')'\\n//    | directDeclarator '[' typeQualifierList? assignmentExpression? ']'\\n//    | directDeclarator '[' 'static' typeQualifierList? assignmentExpression ']'\\n//    | directDeclarator '[' typeQualifierList 'static' assignmentExpression ']'\\n//    | directDeclarator '[' typeQualifierList? '*' ']'\\n//    | directDeclarator '(' parameterTypeList ')'\\n//    | directDeclarator '(' identifierList? ')'\\n//    | Identifier ':' DigitSequence         // bit field\\n//    | vcSpecificModifer Identifier         // Visual C Extension\\n//    | '(' vcSpecificModifer declarator ')' // Visual C Extension\\n//    ;\\npub enum DirectDeclarator {\\n  Identifier(String)\\n  Parenthesized(Declarator)\\n  Array(DirectDeclarator, TypeQualifierList, AssignExpr?)\\n  StaticArray(DirectDeclarator, Array[TypeQualifier], AssignExpr)\\n  VallengthArray(DirectDeclarator, Array[TypeQualifier])\\n  FunctionDecl(DirectDeclarator, ParameterTypeList)\\n  FunctionPtr(DirectDeclarator, Array[String])\\n  BitField(String, Int)\\n} derive(Show, Eq)\\n\\nfn DirectDeclarator::get_ident(self: Self) -> String {\\n  match self {\\n    DirectDeclarator::Identifier(name) => name\\n    Array(inner, _, _) => inner.get_ident()\\n    StaticArray(inner, _, _) => inner.get_ident()\\n    VallengthArray(inner, _) => inner.get_ident()\\n    FunctionDecl(inner, _) => inner.get_ident()\\n    FunctionPtr(inner, _) => inner.get_ident()\\n    BitField(name, _) => name\\n    Parenthesized(inner) => inner.get_ident()\\n  }\\n}\\n\\nfn DirectDeclarator::parse(toks: ArrayView[Token], ctx: Context) -> (DirectDeclarator, ArrayView[Token]) raise {\\n  let (head_decl, rest_toks) = match toks {\\n    [Identifier(name), .. rest_toks] => (DirectDeclarator::Identifier(name), rest_toks)\\n    [LParen, .. rest_toks] => {\\n      let (declarator, rest) = Declarator::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after declarator\\\"))\\n      }\\n      (DirectDeclarator::Parenthesized(declarator), rest)\\n    }\\n    toks => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented direct declarator parsing, current token: \\\\{toks[0]}\\\"))\\n    }\\n  }\\n  let mut current_decl = head_decl\\n  loop rest_toks {\\n    [LBracket, Static, ..rest_toks] => {\\n      let (type_qualifiers, rest_toks) = TypeQualifierList::parse(rest_toks);\\n      let (assign_expr, rest_toks) = AssignExpr::parse(rest_toks, ctx);\\n      current_decl = DirectDeclarator::StaticArray(current_decl, type_qualifiers.inner(), assign_expr)\\n      continue rest_toks\\n    }\\n    [LBracket, ..rest_toks] => {\\n      let (type_qualifiers, rest_toks) = TypeQualifierList::parse(rest_toks);\\n      let rest_toks = match rest_toks {\\n        [Static, .. rest_toks] => {\\n          let (assign_expr, rest) = AssignExpr::parse(rest_toks, ctx);\\n          current_decl = DirectDeclarator::StaticArray(current_decl, type_qualifiers.inner(), assign_expr)\\n          guard rest is [RBracket, ..rest_toks] else {\\n            let idx = ctx.alltoks.length() - rest.length()\\n            raise ParseError((idx, \\\"Parse Error: Expected closing bracket after static array declaration\\\"))\\n          }\\n          rest_toks\\n        }\\n        [Star, .. rest] => {\\n          current_decl = DirectDeclarator::VallengthArray(current_decl, type_qualifiers.inner())\\n          guard rest is [RBracket, ..rest_toks] else {\\n            let idx = ctx.alltoks.length() - rest.length()\\n            raise ParseError((idx, \\\"Parse Error: Expected closing bracket after variable length array declaration\\\"))\\n          }\\n          rest_toks\\n        }\\n        [RBracket, ..rest_toks] => {\\n          current_decl = DirectDeclarator::Array(current_decl, type_qualifiers.inner(), None)\\n          rest_toks\\n        }\\n        _ => {\\n          let (assign_expr, rest) = AssignExpr::parse(rest_toks, ctx);\\n          current_decl = DirectDeclarator::Array(current_decl, type_qualifiers.inner(), Some(assign_expr))\\n          guard rest is [RBracket, ..rest_toks] else {\\n            let idx = ctx.alltoks.length() - rest.length()\\n            raise ParseError((idx, \\\"Parse Error: Expected closing bracket after array declaration\\\"))\\n          }\\n          rest_toks\\n        }\\n      }\\n      continue rest_toks\\n    }\\n    // IdentifierList\\n    [LParen, Identifier(name), Comma, ..rest_toks] => {\\n      let identifiers: Array[String] = [name]\\n      let rest_toks = loop rest_toks {\\n        [Identifier(next_name), ..rest_toks] => {\\n          identifiers.push(next_name)\\n          continue rest_toks\\n        }\\n        [Comma, ..rest_toks] => continue rest_toks\\n        [RParen, ..rest_toks] => {\\n          break rest_toks\\n        }\\n        _ => {\\n          let idx = ctx.alltoks.length() - toks.length()\\n          raise ParseError((idx, \\\"Parse Error: Expected identifier or closing parenthesis in identifier list\\\"))\\n        }\\n      }\\n      current_decl = DirectDeclarator::FunctionPtr(current_decl, identifiers)\\n      continue rest_toks\\n    }\\n    // IdentifierList\\n    [LParen, Identifier(name), RParen, ..rest_toks] => {\\n      let identifiers: Array[String] = [name]\\n      current_decl = DirectDeclarator::FunctionPtr(current_decl, identifiers)\\n      continue rest_toks\\n    }\\n    [LParen, RParen, ..rest_toks] => {\\n      current_decl = DirectDeclarator::FunctionPtr(current_decl, [])\\n      continue rest_toks\\n    }\\n    // parameterTypeList\\n    [LParen, ..rest_toks] => {\\n      let (params, rest) = ParameterTypeList::parse(rest_toks, ctx);\\n      current_decl = DirectDeclarator::FunctionDecl(current_decl, params);\\n      guard rest is [RParen, ..rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after parameter type list\\\"))\\n      }\\n      continue rest_toks\\n    }\\n    // BitField\\n    [Identifier(name), Colon, Constant(Int(i)), ..rest_toks] => {\\n      current_decl = DirectDeclarator::BitField(name, i);\\n      continue rest_toks\\n    }\\n    rest_toks => {\\n      break (current_decl, rest_toks) // No more direct declarators\\n    }\\n  }\\n}\\n\\ntest \\\"DirectDeclarator Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"arr ;\\\" : [Semi, EOF],\\n    \\\"fact() ;\\\" : [Semi, EOF],\\n    \\\"fact(int a) ;\\\" : [Semi, EOF],\\n    \\\"fib(int a, int b) ;\\\" : [Semi, EOF],\\n    \\\"arr[] ;\\\" : [Semi, EOF],\\n    \\\"arr[10] ;\\\" : [Semi, EOF],\\n    \\\"(*fptr)(int, int) ;\\\" : [Semi, EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = DirectDeclarator::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//initDeclarator\\n//    : declarator ('=' initializer)?\\n//    ;\\npub struct InitDeclarator {\\n  declarator: Declarator\\n  initializer: Initializer?\\n} derive(Show, Eq)\\n\\nfn InitDeclarator::get_ident(self: Self) -> String {\\n  self.declarator.get_ident()\\n}\\n\\nfn InitDeclarator::parse(toks: ArrayView[Token], ctx: Context) -> (InitDeclarator, ArrayView[Token]) raise {\\n  let (declarator, rest_toks) = Declarator::parse(toks, ctx);\\n  if rest_toks is [Assign, .. rest_toks] {\\n    let (initializer, rest_toks) = Initializer::parse(rest_toks, ctx);\\n    (InitDeclarator::{ declarator, initializer: Some(initializer) }, rest_toks)\\n  } else {\\n    (InitDeclarator::{ declarator, initializer: None }, rest_toks)\\n  }\\n}\\n\\ntest \\\"InitDeclarator Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"a;\\\" : [Semi, EOF],\\n    \\\"b = 10;\\\" : [Semi, EOF],\\n    \\\"arr[] = {1, 2, 3, 4, 5};\\\" : [Semi, EOF],\\n    \\\"*p = 4;\\\" : [Semi, EOF],\\n    \\\"*p;\\\" : [Semi, EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = InitDeclarator::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\npriv type InitDeclaratorList Array[InitDeclarator]\\n\\nfn InitDeclaratorList::parse(toks: ArrayView[Token], ctx: Context) -> (InitDeclaratorList, ArrayView[Token]) raise {\\n  let decls: Array[InitDeclarator] = Array::new()\\n  let (first_decl, rest_toks) = InitDeclarator::parse(toks, ctx);\\n  decls.push(first_decl)\\n  let rest_toks = loop rest_toks {\\n    [Comma, .. rest_toks] => {\\n      let (next_decl, rest) = InitDeclarator::parse(rest_toks, ctx);\\n      decls.push(next_decl)\\n      continue rest\\n    }\\n    toks => break toks // no more init declarators\\n  }\\n  (InitDeclaratorList(decls), rest_toks)\\n}\\n\\n\\n//initializer\\n//    : assignmentExpression\\n//    | '{' initializerList ','? '}'\\n//    ;\\n//\\n//initializerList\\n//    : designation? initializer (',' designation? initializer)*\\n//    ;\\n//\\n//designation\\n//    : designatorList '='\\n//    ;\\n//\\n//designatorList\\n//    : designator+\\n//    ;\\n//\\n//designator\\n//    : '[' constantExpression ']'\\n//    | '.' Identifier\\n//    ;\\npub enum Initializer {\\n  AssignExpr(AssignExpr)\\n  InitList(Array[(Array[Designator], Initializer)])\\n} derive(Show, Eq)\\n\\n\\nfn Initializer::parse(toks: ArrayView[Token], ctx: Context) -> (Initializer, ArrayView[Token]) raise {\\n  match toks {\\n    [LBrace, ..] as toks => {\\n      let (init_list, rest) = InitializerList::parse(toks, ctx);\\n      (Initializer::InitList(init_list.inner()), rest)\\n    }\\n    _ => {\\n      let (assign_expr, rest) = AssignExpr::parse(toks, ctx);\\n      (Initializer::AssignExpr(assign_expr), rest)\\n    }\\n  }\\n}\\n\\npriv type InitializerList Array[(Array[Designator], Initializer)]\\n\\nfn InitializerList::parse(toks: ArrayView[Token], ctx: Context) -> (InitializerList, ArrayView[Token]) raise {\\n  guard toks is [LBrace, .. toks] else {\\n    let idx = ctx.alltoks.length() - toks.length()\\n    raise ParseError((idx, \\\"Parse Error: Expected '{' to start initializer list\\\"))\\n  }\\n  let init_list: Array[(Array[Designator], Initializer)] = Array::new()\\n  loop toks {\\n    [Dot | LBracket, ..] as toks => {\\n      let (designators, rest) = DesignatorList::parse(toks, ctx);\\n      guard rest is [Assign, .. rest] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected '=' after designator list in initializer\\\"))\\n      }\\n      let (initializer, rest) = Initializer::parse(rest, ctx);\\n      init_list.push((designators.inner(), initializer))\\n      continue rest\\n    }\\n    [Comma, .. rest_toks] => {\\n      // Skip commas\\n      continue rest_toks\\n    }\\n    [RBrace, .. rest_toks] => {\\n      // End of initializer list\\n      break (InitializerList(init_list), rest_toks)\\n    }\\n    toks => { \\n      // If we reach here, it means we have an initializer without designators\\n      let (initializer, rest) = Initializer::parse(toks, ctx);\\n      init_list.push((Array::new(), initializer))\\n      continue rest\\n    }\\n  }\\n}\\n\\ntest \\\"InitializerList Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"{1, 2, 3}\\\" : [EOF],\\n    \\\"{.field = 1, .other = 2}\\\" : [EOF],\\n    \\\"{[0] = 1, [1] = 2}\\\" : [EOF],\\n    \\\"{.field = {1, 2}, .other = {3}}\\\" : [EOF],\\n    \\\"{{1, 2}, {3, 4}}\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = InitializerList::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//designator\\n//    : '[' constantExpression ']'\\n//    | '.' Identifier\\n//    ;\\npub enum Designator {\\n  ConstExpr(ConstantExpr)\\n  DotAccess(String)\\n} derive(Show, Eq)\\n\\nfn Designator::parse(toks: ArrayView[Token], ctx: Context) -> (Designator, ArrayView[Token]) raise {\\n  match toks {\\n    [LBracket, .. rest_toks] => {\\n      let (const_expr, rest) = ConstantExpr::parse(rest_toks, ctx);\\n      guard rest is [RBracket, .. rest] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing bracket after constant expression in designator\\\"))\\n      }\\n      (Designator::ConstExpr(const_expr), rest)\\n    }\\n    [Dot, Identifier(name), .. rest_toks] => (Designator::DotAccess(name), rest_toks)\\n    toks => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented designator parsing, current token: \\\\{toks[0]}\\\"))\\n    }\\n  }\\n}\\n\\npriv type DesignatorList Array[Designator]\\n\\nfn DesignatorList::parse(toks: ArrayView[Token], ctx: Context) -> (DesignatorList, ArrayView[Token]) raise {\\n  let designators: Array[Designator] = Array::new()\\n  let rest_toks = loop toks {\\n    [LBracket | Dot, ..] as toks => {\\n      let (designator, rest) = Designator::parse(toks, ctx);\\n      designators.push(designator)\\n      continue rest\\n    }\\n    toks => break toks // no more designators\\n  }\\n  (DesignatorList(designators), rest_toks)\\n}\\n\\ntest \\\"DesignatorList Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"[0]\\\" : [EOF],\\n    \\\".field\\\" : [EOF],\\n    \\\"[1].field\\\" : [EOF],\\n    \\\"[2][3].field\\\" : [EOF],\\n    \\\"[1].field[2]\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = DesignatorList::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n\\n//enumSpecifier\\n//    : 'enum' Identifier? '{' enumeratorList ','? '}'\\n//    | 'enum' Identifier\\n//    ;\\n//\\n//enumeratorList\\n//    : enumerator (',' enumerator)*\\n//    ;\\n//\\n//enumerator\\n//    : enumerationConstant ('=' constantExpression)?\\n//    ;\\n//\\n//enumerationConstant\\n//    : Identifier\\n//    ;\\npub struct EnumSpec {\\n  name: String?\\n  enumerators: Array[Enumerator]\\n} derive(Show, Eq)\\n\\nfn EnumSpec::parse(toks: ArrayView[Token], ctx: Context) -> (EnumSpec, ArrayView[Token]) raise {\\n  guard toks is [Enum, .. toks] else {\\n    let idx = ctx.alltoks.length() - toks.length()\\n    raise ParseError((idx, \\\"Parse Error: Expected 'enum' keyword for enum specification\\\"))\\n  }\\n\\n  match toks {\\n    [Identifier(name), LBrace, RBrace, .. rest_toks] => {\\n      // Anonymous enum with no enumerators\\n      (EnumSpec::{ name: Some(name), enumerators: Array::new() }, rest_toks)\\n    }\\n    [Identifier(name), LBrace, .. rest_toks] => {\\n      let (enumerators, rest) = EnumeratorList::parse(rest_toks, ctx);\\n      let enumerators = enumerators.inner()\\n      guard rest is [RBrace, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing brace after enumerator list in enum specification\\\"))\\n      }\\n      (EnumSpec::{ name: Some(name), enumerators }, rest_toks)\\n    }\\n    [Identifier(name), .. rest_toks] => {\\n      (EnumSpec::{ name: Some(name), enumerators: Array::new() }, rest_toks)\\n    }\\n    [LBrace, RBrace, .. rest_toks] => {\\n      // Anonymous enum with no enumerators\\n      (EnumSpec::{ name: None, enumerators: Array::new() }, rest_toks)\\n    }\\n    [LBrace, .. rest_toks] => {\\n      // Anonymous enum\\n      let (enumerators, rest) = EnumeratorList::parse(rest_toks, ctx);\\n      let enumerators = enumerators.inner()\\n      guard rest is [RBrace, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing brace after enumerator list in anonymous enum\\\"))\\n      }\\n      (EnumSpec::{ name: None, enumerators }, rest_toks)\\n    }\\n    _ => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented enum specification parsing, current token: \\\\{toks[0]}\\\"))\\n    }\\n  }\\n}\\n\\ntest \\\"EnumSpec Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"enum MyEnum { A, B, C }\\\" : [EOF],\\n    \\\"enum { Red, Yellow, Blue }\\\" : [EOF],\\n    \\\"enum EmptyEnum {}\\\" : [EOF],\\n    \\\"enum AnotherEnum { ONE = 1, TWO = 2 }\\\" : [EOF],\\n    \\\"enum SingleEnum { ONLY }\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = EnumSpec::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\ntype Enumerator (String, ConstantExpr?) derive(Show, Eq)\\n\\nfn Enumerator::parse(toks: ArrayView[Token], ctx: Context) -> (Enumerator, ArrayView[Token]) raise {\\n  match toks {\\n    [Identifier(name), Assign, .. rest_toks] => {\\n      let (const_expr, rest_toks) = ConstantExpr::parse(rest_toks, ctx);\\n      (Enumerator((name, Some(const_expr))), rest_toks)\\n    }\\n    [Identifier(name), .. rest_toks] => (Enumerator((name, None)), rest_toks)\\n    _ => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented enumerator parsing, current token: \\\\{toks[0]}\\\"))\\n    }\\n  }\\n}\\n\\n\\npriv type EnumeratorList Array[Enumerator]\\n\\nfn EnumeratorList::parse(toks: ArrayView[Token], ctx: Context) -> (EnumeratorList, ArrayView[Token]) raise {\\n  let enumerators: Array[Enumerator] = Array::new()\\n  let (first_enum, rest_toks) = Enumerator::parse(toks, ctx);\\n  enumerators.push(first_enum)\\n  let rest_toks = loop rest_toks {\\n    [Comma, .. rest_toks] => {\\n      let (next_enum, rest) = Enumerator::parse(rest_toks, ctx);\\n      enumerators.push(next_enum)\\n      continue rest\\n    }\\n    [RBrace, ..] as toks => {\\n      break toks // End of enumerator list\\n    }\\n    rest_toks => {\\n      let idx = ctx.alltoks.length() - rest_toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Expected comma or closing brace in enumerator list, current token: \\\\{rest_toks[0]}\\\"))\\n    }\\n  }\\n  (enumerators, rest_toks)\\n}\\n\\n\\n//functionSpecifier\\n//    : 'inline'\\n//    | '_Noreturn'\\n//    | '__inline__' // GCC extension\\n//    | '__stdcall'\\n//    | gccAttributeSpecifier\\n//    | '__declspec' '(' Identifier ')'\\n//    ;\\npub enum FunctionSpec {\\n  Inline // inline\\n  Noreturn // _Noreturn\\n} derive(Show, Eq)\\n\\nfn FunctionSpec::parse(toks: ArrayView[Token], ctx: Context) -> (FunctionSpec, ArrayView[Token]) raise {\\n  match toks {\\n    [Inline, .. rest_toks] => (FunctionSpec::Inline, rest_toks)\\n    [Noreturn, .. rest_toks] => (FunctionSpec::Noreturn, rest_toks)\\n    _ => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented function specifier\\\"))\\n    }\\n  }\\n}\\n\\npub enum AlignmentSpec {\\n  AlignasExpr(ConstantExpr) // _Alignas(expr)\\n  AlignasType(TypeName) // _Alignof(type)\\n} derive(Show, Eq)\\n\\nfn AlignmentSpec::parse(toks: ArrayView[Token], ctx: Context) -> (AlignmentSpec, ArrayView[Token]) raise {\\n  match toks {\\n    [Alignas, LParen, .. rest_toks] => {\\n      let (expr, rest) = ConstantExpr::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after expression in _Alignas\\\"))\\n      }\\n      (AlignmentSpec::AlignasExpr(expr), rest)\\n    }\\n    [Alignof, LParen, .. rest_toks] => {\\n      let (type_name, rest) = TypeName::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after type name in _Alignof\\\"))\\n      }\\n      (AlignmentSpec::AlignasType(type_name), rest)\\n    }\\n    toks => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented alignment specifier, current token: \\\\{toks[0]}\\\"))\\n    }\\n  }\\n}\\n\\n\\n//typeName\\n//    : specifierQualifierList abstractDeclarator?\\n//    ;\\npub struct TypeName {\\n  specifiers: Array[TypeSpecOrQualifier]\\n  abstract_declarator: AbstractDeclarator?\\n} derive(Show, Eq)\\n\\nfn TypeName::parse(toks: ArrayView[Token], ctx: Context) -> (TypeName, ArrayView[Token]) raise {\\n  let specifiers: Array[TypeSpecOrQualifier] = Array::new()\\n  let mut rest_toks = toks\\n  while (try? TypeSpecOrQualifier::parse(rest_toks, ctx)) is Ok((spec, rest)) {\\n    specifiers.push(spec)\\n    rest_toks = rest\\n  }\\n  let (abstract_declarator, rest_toks) = if rest_toks is [Star | LParen | LBracket, ..] { \\n    let (a, rest) = AbstractDeclarator::parse(rest_toks, ctx);\\n    (Some(a), rest)\\n  } else {\\n    (None, rest_toks)\\n  }\\n  let type_name = TypeName::{\\n    specifiers,\\n    abstract_declarator\\n  }\\n  (type_name, rest_toks)\\n}\\n\\ntest \\\"TypeName Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"int *ptr\\\" : [Identifier(\\\"ptr\\\"), EOF],\\n    \\\"char **str\\\" : [Identifier(\\\"str\\\"), EOF],\\n    \\\"const char ** msg\\\" : [Identifier(\\\"msg\\\"), EOF],\\n    \\\"int const * arr\\\" : [Identifier(\\\"arr\\\"), EOF],\\n    \\\"int * const arr\\\" : [Identifier(\\\"arr\\\"), EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    //let toks = lex(code)\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = TypeName::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//abstractDeclarator\\n//    : pointer\\n//    | pointer? directAbstractDeclarator gccDeclaratorExtension*\\n//    ;\\npub struct AbstractDeclarator {\\n  pointer: Pointer?\\n  directAbstractDeclarator: DirectAbstractDeclarator?\\n} derive(Show, Eq)\\n\\nfn AbstractDeclarator::parse(toks: ArrayView[Token], ctx: Context) -> (AbstractDeclarator, ArrayView[Token]) raise {\\n  match toks {\\n    [Star, ..] => {\\n      let (pointer, rest_toks) = Pointer::parse(toks);\\n      let (direct_abstract_declarator, rest_toks) = DirectAbstractDeclarator::parse(rest_toks, ctx);\\n      let abstract_declarator = AbstractDeclarator::{\\n        pointer: Some(pointer),\\n        directAbstractDeclarator: direct_abstract_declarator\\n      }\\n      (abstract_declarator, rest_toks)\\n    }\\n    [LParen | LBracket, ..] as toks => {\\n      let (direct_abstract_declarator, rest_toks) = DirectAbstractDeclarator::parse(toks, ctx);\\n      let abstract_declarator = AbstractDeclarator::{\\n        pointer: None,\\n        directAbstractDeclarator: direct_abstract_declarator\\n      }\\n      (abstract_declarator, rest_toks)\\n    }\\n    toks => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented abstract declarator parsing, current token: \\\\{toks[0]}\\\"))\\n    }\\n  }\\n}\\n\\ntest \\\"AbstractDeclarator Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"*\\\" : [EOF],\\n    \\\"[*]\\\" : [EOF],\\n    \\\"[10]\\\" : [EOF],\\n    \\\"[a][10]\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = AbstractDeclarator::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//\\n//directAbstractDeclarator\\n//    : '(' abstractDeclarator ')' gccDeclaratorExtension*\\n//    | '[' typeQualifierList? assignmentExpression? ']'\\n//    | '[' 'static' typeQualifierList? assignmentExpression ']'\\n//    | '[' typeQualifierList 'static' assignmentExpression ']'\\n//    | '[' '*' ']'\\n//    | '(' parameterTypeList? ')' gccDeclaratorExtension*\\n//    | directAbstractDeclarator '[' typeQualifierList? assignmentExpression? ']'\\n//    | directAbstractDeclarator '[' 'static' typeQualifierList? assignmentExpression ']'\\n//    | directAbstractDeclarator '[' typeQualifierList 'static' assignmentExpression ']'\\n//    | directAbstractDeclarator '[' '*' ']'\\n//    | directAbstractDeclarator '(' parameterTypeList? ')' gccDeclaratorExtension*\\n//    ;\\npub enum DirectAbstractDeclarator {\\n  FuncDecl(DirectAbstractDeclarator?, ParameterTypeList)\\n  ArrayDecl(DirectAbstractDeclarator?, is_static~:Bool, Array[TypeQualifier], AssignExpr?) // Bool indicates if it's a static array\\n  InCompleteArray(DirectAbstractDeclarator?) // '[' '*' ']'\\n  FuncPtr(DirectAbstractDeclarator?, AbstractDeclarator)\\n} derive(Show, Eq)\\n\\n// TODO: Not Correct Implementation\\nfn DirectAbstractDeclarator::parse(toks: ArrayView[Token], ctx:Context) -> (DirectAbstractDeclarator?, ArrayView[Token]) raise {\\n  let (head_decl, rest_toks) = match toks {\\n    [LParen, Star | LBracket | LParen, ..] as toks => {\\n      let (abstract_declarator, rest) = AbstractDeclarator::parse(toks[1:], ctx);\\n      guard rest is [RParen, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after abstract declarator\\\"))\\n      }\\n      (DirectAbstractDeclarator::FuncPtr(None, abstract_declarator), rest_toks)\\n    }\\n    [LParen, .. rest_toks] => {\\n      let (parameter_type_list, rest) = ParameterTypeList::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after parameter type list\\\"))\\n      }\\n      (DirectAbstractDeclarator::FuncDecl(None, parameter_type_list), rest_toks)\\n    }\\n    [LBracket, Star, RBracket, .. rest_toks] => {\\n      (DirectAbstractDeclarator::InCompleteArray(None), rest_toks)\\n    }\\n    [LBracket, Static, tok, ..] as toks if ctx.is_declspec_tok(tok) => {\\n      let (type_qualifiers, rest_toks) = TypeQualifierList::parse(toks[2:]);\\n      let (assign_expr, rest_toks) = if !(rest_toks is [RBracket, ..]) {\\n        let (assign_expr, rest_toks) = AssignExpr::parse(rest_toks, ctx);\\n        (Some(assign_expr), rest_toks)\\n      } else {\\n        (None, rest_toks)\\n      }\\n      (DirectAbstractDeclarator::ArrayDecl(None, is_static=true, type_qualifiers.inner(), assign_expr), rest_toks)\\n    }\\n    [LBracket, tok, ..] as toks if ctx.is_declspec_tok(tok) => {\\n      let (type_qualifiers, rest_toks) = TypeQualifierList::parse(toks[1:]);\\n      let (is_static, rest_toks) = if rest_toks is [Static, ..] {\\n        (true, rest_toks[1:])\\n      } else {\\n        (false, rest_toks)\\n      }\\n      let (assign_expr, rest_toks) = if !(rest_toks is [RBracket, ..]) {\\n        let (assign_expr, rest_toks) = AssignExpr::parse(rest_toks, ctx);\\n        (Some(assign_expr), rest_toks)\\n      } else {\\n        (None, rest_toks)\\n      }\\n      (DirectAbstractDeclarator::ArrayDecl(None, is_static~, type_qualifiers.inner(), assign_expr), rest_toks)\\n    }\\n    [LBracket, RBracket, .. rest_toks] => {\\n      (DirectAbstractDeclarator::ArrayDecl(None, is_static=false, Array::new(), None), rest_toks)\\n    }\\n    [LBracket, .. rest_toks] => {\\n      let (assign_expr, rest) = AssignExpr::parse(rest_toks, ctx);\\n      guard rest is [RBracket, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing bracket after array declaration\\\"))\\n      }\\n      (DirectAbstractDeclarator::ArrayDecl(None, is_static=false, Array::new(), Some(assign_expr)), rest_toks)\\n    }\\n    toks => return (None, toks) // No direct abstract declarator\\n  }\\n  let mut curr_decl = head_decl;\\n  loop rest_toks {\\n    [LParen, .. rest_toks] => {\\n      let (parameter_type_list, rest) = ParameterTypeList::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after parameter type list\\\"))\\n      }\\n      curr_decl = DirectAbstractDeclarator::FuncDecl(Some(curr_decl), parameter_type_list);\\n      continue rest_toks\\n    }\\n    [LBracket, Star, RBracket, .. rest_toks] => {\\n      curr_decl = DirectAbstractDeclarator::InCompleteArray(Some(curr_decl));\\n      continue rest_toks\\n    }\\n    [LBracket, Static, tok, ..] as toks if ctx.is_declspec_tok(tok) => {\\n      let (type_qualifiers, rest_toks) = TypeQualifierList::parse(toks[2:]);\\n      let (assign_expr, rest_toks) = if !(rest_toks is [RBracket, ..]) {\\n        let (assign_expr, rest_toks) = AssignExpr::parse(rest_toks, ctx);\\n        (Some(assign_expr), rest_toks)\\n      } else {\\n        (None, rest_toks)\\n      }\\n      curr_decl = DirectAbstractDeclarator::ArrayDecl(Some(curr_decl), is_static=true, type_qualifiers.inner(), assign_expr);\\n      continue rest_toks\\n    }\\n    [LBracket, tok, ..] as toks if ctx.is_declspec_tok(tok) => {\\n      let (type_qualifiers, rest_toks) = TypeQualifierList::parse(toks[1:]);\\n      let (is_static, rest_toks) = if rest_toks is [Static, ..] {\\n        (true, rest_toks[1:])\\n      } else {\\n        (false, rest_toks)\\n      }\\n      let (assign_expr, rest_toks) = if !(rest_toks is [RBracket, ..]) {\\n        let (assign_expr, rest_toks) = AssignExpr::parse(rest_toks, ctx);\\n        (Some(assign_expr), rest_toks)\\n      } else {\\n        (None, rest_toks)\\n      }\\n      curr_decl = DirectAbstractDeclarator::ArrayDecl(Some(curr_decl), is_static~, type_qualifiers.inner(), assign_expr);\\n      continue rest_toks\\n    }\\n    [LBracket, RBracket, .. rest_toks] => {\\n      curr_decl = DirectAbstractDeclarator::ArrayDecl(Some(curr_decl), is_static=false, Array::new(), None);\\n      continue rest_toks\\n    }\\n    [LBracket, .. rest_toks] => {\\n      let (assign_expr, rest) = AssignExpr::parse(rest_toks, ctx);\\n      guard rest is [RBracket, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing bracket after array declaration\\\"))\\n      }\\n      curr_decl = DirectAbstractDeclarator::ArrayDecl(Some(curr_decl), is_static=false, Array::new(), Some(assign_expr));\\n      continue rest_toks\\n    }\\n    rest_toks => break (Some(curr_decl), rest_toks) // No more direct abstract declarators\\n  }\\n}\\n\\n//statement\\n//    : labeledStatement\\n//    | compoundStatement\\n//    | expressionStatement\\n//    | selectionStatement\\n//    | iterationStatement\\n//    | jumpStatement\\n//    | ('__asm' | '__asm__') ('volatile' | '__volatile__') '(' (\\n//        logicalOrExpression (',' logicalOrExpression)*\\n//    )? (':' (logicalOrExpression (',' logicalOrExpression)*)?)* ')' ';'\\n//    ;\\npub enum Statement {\\n  Empty // Empty statement, just a semicolon\\n  LabeledStatement(LabeledStatement)\\n  CompoundStatement(CompoundStatement)\\n  ExpressionStatement(Expr)\\n  SelectionStatement(SelectionStatement)\\n  IterationStatement(IterationStatement)\\n  JumpStatement(JumpStatement)\\n  // Asm\\n  // volatile\\n} derive(Show, Eq)\\n\\nfn Statement::parse(toks: ArrayView[Token], ctx: Context) -> (Statement, ArrayView[Token]) raise {\\n  match toks {\\n    [LBrace, ..] as toks => {\\n      let (compound_statement, rest_toks) = CompoundStatement::parse(toks, ctx);\\n      (Statement::CompoundStatement(compound_statement), rest_toks)\\n    }\\n    [If | Switch, ..] as toks => {\\n      let (selection_statement, rest_toks) = SelectionStatement::parse(toks, ctx);\\n      (Statement::SelectionStatement(selection_statement), rest_toks)\\n    }\\n    [For | While | Do, ..] as toks => {\\n      let (iteration_statement, rest_toks) = IterationStatement::parse(toks, ctx);\\n      (Statement::IterationStatement(iteration_statement), rest_toks)\\n    }\\n    [Identifier(_), Colon, ..] as toks => {\\n      let (labeled_statement, rest_toks) = LabeledStatement::parse(toks, ctx);\\n      (Statement::LabeledStatement(labeled_statement), rest_toks)\\n    }\\n    [Case | Default, ..] as toks => {\\n      let (labeled_statement, rest_toks) = LabeledStatement::parse(toks, ctx);\\n      (Statement::LabeledStatement(labeled_statement), rest_toks)\\n    }\\n    [Goto | Continue | Break | Return, ..] as toks => {\\n      let (jump_statement, rest_toks) = JumpStatement::parse(toks, ctx);\\n      (Statement::JumpStatement(jump_statement), rest_toks)\\n    }\\n    [Semi, .. rest_toks] => {\\n      (Statement::Empty, rest_toks)\\n    }\\n    _ => {\\n      let (expr, rest) = Expr::parse(toks, ctx);\\n      guard rest is [Semi, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected ';' after expression statement\\\"))\\n      }\\n      (Statement::ExpressionStatement(expr), rest_toks)\\n    }\\n  }\\n}\\n\\ntest \\\"Statement Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"x = 10;\\\" : [EOF],\\n    \\\"if (x) { y++; }\\\" : [EOF],\\n    \\\"while (x < 10) { x++; }\\\" : [EOF],\\n    \\\"for (int i = 0; i < 10; i++) { sum += i; }\\\" : [EOF],\\n    \\\"goto label;\\\" : [EOF],\\n    \\\"label: x = 10;\\\" : [EOF],\\n    \\\"{ int a; }\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = Statement::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//labeledStatement\\n//    : Identifier ':' statement\\n//    | 'case' constantExpression ':' statement\\n//    | 'default' ':' statement\\n//    ;\\npub enum LabeledStatement {\\n  Label(String, Statement)\\n  Case(ConstantExpr, Statement)\\n  Default(Statement)\\n} derive(Show, Eq)\\n\\nfn LabeledStatement::parse(toks: ArrayView[Token], ctx: Context) -> (LabeledStatement, ArrayView[Token]) raise {\\n  match toks {\\n    [Identifier(name), Colon, .. rest_toks] => {\\n      let (statement, rest_toks) = Statement::parse(rest_toks, ctx);\\n      (LabeledStatement::Label(name, statement), rest_toks)\\n    }\\n    [Case, ..rest_toks] => {\\n      let (const_expr, rest) = ConstantExpr::parse(rest_toks, ctx);\\n      guard rest is [Colon, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected ':' after case constant expression\\\"))\\n      }\\n      let (statement, rest_toks) = Statement::parse(rest_toks, ctx);\\n      (LabeledStatement::Case(const_expr, statement), rest_toks)\\n    }\\n    [Default, Colon, .. rest_toks] => {\\n      let (statement, rest_toks) = Statement::parse(rest_toks, ctx);\\n      (LabeledStatement::Default(statement), rest_toks)\\n    }\\n    toks => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented labeled statement parsing, current token: \\\\{toks[0]}\\\"))\\n    }\\n  }\\n}\\n\\ntest \\\"LabeledStatement Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"label: x = 10;\\\" : [EOF],\\n    \\\"case 1: y++;\\\" : [EOF],\\n    \\\"default: z--;\\\" : [EOF],\\n    \\\"myLabel: if (x) { y++; }\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = LabeledStatement::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\npub struct CompoundStatement {\\n  items: Array[BlockItem]\\n} derive(Show, Eq)\\n\\nfn CompoundStatement::parse(toks: ArrayView[Token], ctx: Context) -> (CompoundStatement, ArrayView[Token]) raise {\\n  guard toks is [LBrace, .. toks] else {\\n    let idx = ctx.alltoks.length() - toks.length()\\n    raise ParseError((idx, \\\"Parse Error: Expected '{' for compound statement\\\"))\\n  }\\n  ctx.enter_scope()\\n  let items: Array[BlockItem] = Array::new()\\n  loop toks {\\n    [RBrace, .. rest_toks] => {\\n      ctx.leave_scope()\\n      break (CompoundStatement::{items}, rest_toks) // End of compound statement\\n    }\\n    [Semi, .. rest_toks] => {\\n      // Empty statement, just skip it\\n      continue rest_toks\\n    }\\n    toks => {\\n      let (item, rest_toks) = BlockItem::parse(toks, ctx);\\n      items.push(item);\\n      continue rest_toks\\n    }\\n  }\\n}\\n\\ntest \\\"CompoundStatement Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"{ int a; }\\\" : [EOF],\\n    \\\"{ int a; int b; }\\\" : [EOF],\\n    \\\"{ int a = 1, b = 2; c = a + b;}\\\": [EOF],\\n    \\\"{ if (x) { y++; } else { y--; } }\\\" : [EOF],\\n    \\\"{ while (x < 10) { x++; } }\\\" : [EOF],\\n    \\\"{ for (int i = 0; i < 10; i++) { sum += i; } }\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = CompoundStatement::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\npub enum BlockItem {\\n  Statement(Statement)\\n  Declaration(Declaration)\\n} derive(Show, Eq)\\n\\nfn BlockItem::parse(toks: ArrayView[Token], ctx: Context) -> (BlockItem, ArrayView[Token]) raise {\\n  if ctx.is_declspec_tok(toks[0]) {\\n    let (decl, rest_toks) = Declaration::parse(toks, ctx);\\n    (BlockItem::Declaration(decl), rest_toks)\\n  } else {\\n    let (stmt, rest_toks) = Statement::parse(toks, ctx);\\n    (BlockItem::Statement(stmt), rest_toks)\\n  }\\n}\\n\\npub enum SelectionStatement {\\n  If(Expr, Statement, Statement?)\\n  Switch(Expr, Statement)\\n} derive(Show, Eq)\\n\\nfn SelectionStatement::parse(toks: ArrayView[Token], ctx: Context) -> (SelectionStatement, ArrayView[Token]) raise {\\n  match toks {\\n    [If, LParen, .. rest_toks] => {\\n      let (expr, rest) = Expr::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after if condition\\\"))\\n      }\\n      let (then_stmt, rest_toks) = Statement::parse(rest_toks, ctx);\\n      let (else_stmt, rest_toks) = if rest_toks is [Else, .. rest_toks] {\\n        let (else_stmt, rest_toks) = Statement::parse(rest_toks, ctx);\\n        (Some(else_stmt), rest_toks)\\n      } else {\\n        (None, rest_toks)\\n      }\\n      (SelectionStatement::If(expr, then_stmt, else_stmt), rest_toks)\\n    }\\n    [Switch, LParen, .. rest_toks] => {\\n      let (expr, rest) = Expr::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after switch condition\\\"))\\n      }\\n      let (stmt, rest_toks) = Statement::parse(rest_toks, ctx);\\n      (SelectionStatement::Switch(expr, stmt), rest_toks)\\n    }\\n    toks => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented selection statement parsing, current token: \\\\{toks[0]}\\\"))\\n    }\\n  }\\n}\\n\\ntest \\\"SelectionStatement Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"if (x < 10) { x++; } else { x--; }\\\" : [EOF],\\n    \\\"if (x < 10) { x++; }\\\" : [EOF],\\n    \\\"switch (x) { case 1: y++; break; default: y--; }\\\" : [EOF],\\n    \\\"switch (x) { case 1: y++; }\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = SelectionStatement::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\npub enum IterationStatement {\\n  While(Expr, Statement)\\n  DoWhile(Statement, Expr)\\n  For(ForCondition, Statement)\\n} derive(Show, Eq)\\n\\nfn IterationStatement::parse(toks: ArrayView[Token], ctx: Context) -> (IterationStatement, ArrayView[Token]) raise {\\n  match toks {\\n    [While, LParen, .. rest_toks] => {\\n      let (expr, rest) = Expr::parse(rest_toks, ctx);\\n      guard rest is [RParen, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis after while condition\\\"))\\n      }\\n      let (stmt, rest_toks) = Statement::parse(rest_toks, ctx);\\n      (IterationStatement::While(expr, stmt), rest_toks)\\n    }\\n    [Do, .. rest_toks] => {\\n      let (stmt, rest) = Statement::parse(rest_toks, ctx);\\n      guard rest is [While, LParen, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected 'while' after do-while statement\\\"))\\n      }\\n      let (expr, rest) = Expr::parse(rest_toks, ctx);\\n      guard rest is [RParen, Semi, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis and ';' after do-while condition\\\"))\\n      }\\n      (IterationStatement::DoWhile(stmt, expr), rest_toks)\\n    }\\n    [For, ..] => {\\n      let (for_cond, rest_toks) = ForCondition::parse(toks, ctx);\\n      let (stmt, rest_toks) = Statement::parse(rest_toks, ctx);\\n      (IterationStatement::For(for_cond, stmt), rest_toks)\\n    }\\n    toks => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented iteration statement parsing, current token: \\\\{toks[0]}\\\"))\\n    }\\n  }\\n}\\n\\ntest \\\"IterationStatement Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"while (x < 10) { x++; }\\\" : [EOF],\\n    \\\"do { x++; } while (x < 10);\\\" : [EOF],\\n    \\\"for (int i = 0; i < 10; i++) { sum += i; }\\\" : [EOF],\\n    \\\"for (int i = 0;;) { sum += i; }\\\" : [EOF],\\n    \\\"for (;;) { break; }\\\" : [EOF],\\n    \\\"while (i < 10) i++;\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = IterationStatement::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//forCondition\\n//    : (forDeclaration | expression?) ';' forExpression? ';' forExpression?\\n//    ;\\npub struct ForCondition {\\n  for_init: ForInit\\n  cond: Array[AssignExpr]\\n  inc: Array[AssignExpr]\\n} derive(Show, Eq)\\n\\nfn ForCondition::parse(toks: ArrayView[Token], ctx: Context) -> (ForCondition, ArrayView[Token]) raise {\\n  guard toks is [For, LParen, .. toks] else {\\n    let idx = ctx.alltoks.length() - toks.length()\\n    raise ParseError((idx, \\\"Parse Error: Expected 'for' condition to start with 'for('\\\"))\\n  }\\n  let (for_init, rest_toks) = ForInit::parse(toks, ctx);\\n  let (cond, rest_toks) = if rest_toks is [Semi, .. rest_toks] {\\n    (Array::new(), rest_toks) // No condition\\n  } else {\\n    let (expr, rest) = Expr::parse(rest_toks, ctx);\\n    guard rest is [Semi, .. rest_toks] else {\\n      //raise ParseError(\\\"Expected ';' after for condition expression\\\")\\n      let idx = ctx.alltoks.length() - rest.length()\\n      raise ParseError((idx, \\\"Parse Error: Expected ';' after for condition expression\\\"))\\n    }\\n    (expr.exprs, rest_toks)\\n  }\\n\\n  let (inc, rest_toks) = if rest_toks is [RParen, .. rest_toks] {\\n    (Array::new(), rest_toks) // No increment\\n  } else {\\n    let (expr, rest) = Expr::parse(rest_toks, ctx);\\n    guard rest is [RParen, .. rest_toks] else {\\n      let idx = ctx.alltoks.length() - rest.length()\\n      raise ParseError((idx, \\\"Parse Error: Expected closing parenthesis and ';' after for increment expression\\\"))\\n    }\\n    (expr.exprs, rest_toks)\\n  }\\n  let for_condition = ForCondition::{ for_init, cond, inc }\\n  (for_condition, rest_toks)\\n}\\n\\npub struct ForInit {\\n  decl: Array[Declaration]\\n  initDecl: Array[InitDeclarator]\\n} derive(Show, Eq)\\n\\nfn ForInit::parse(toks: ArrayView[Token], ctx: Context) -> (ForInit, ArrayView[Token]) raise {\\n  let decls: Array[Declaration] = Array::new()\\n  let init_decls: Array[InitDeclarator] = Array::new()\\n  loop toks {\\n    [Semi, .. rest_toks] => {\\n      // Empty initialization, just skip it\\n      break (ForInit::{ decl: decls, initDecl: init_decls }, rest_toks)\\n    }\\n    [Comma, .. rest_toks] => {\\n      // Skip commas\\n      continue rest_toks\\n    }\\n    [tok, ..] as toks if ctx.is_declspec_tok(tok) => {\\n      let (decl, rest_toks) = Declaration::parse(toks, ctx);\\n      decls.push(decl);\\n      continue rest_toks\\n    }\\n    toks => {\\n      let (init_decl, rest_toks) = InitDeclarator::parse(toks, ctx);\\n      init_decls.push(init_decl);\\n      continue rest_toks\\n    }\\n  }\\n}\\n\\npub enum JumpStatement {\\n  Goto(String)\\n  Continue\\n  Break\\n  Return(Expr?)\\n} derive(Show, Eq)\\n\\nfn JumpStatement::parse(toks: ArrayView[Token], ctx: Context) -> (JumpStatement, ArrayView[Token]) raise {\\n  match toks {\\n    [Goto, Identifier(name), Semi, .. rest_toks] => (JumpStatement::Goto(name), rest_toks)\\n    [Continue, Semi, .. rest_toks] => (JumpStatement::Continue, rest_toks)\\n    [Break, Semi, .. rest_toks] => (JumpStatement::Break, rest_toks)\\n    [Return, Semi, .. rest_toks] => (JumpStatement::Return(None), rest_toks)\\n    [Return, .. rest_toks] => {\\n      let (expr, rest) = Expr::parse(rest_toks, ctx);\\n      guard rest is [Semi, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected ';' after return expression\\\"))\\n      }\\n      (JumpStatement::Return(Some(expr)), rest_toks)\\n    }\\n    toks => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Unimplemented jump statement parsing, current token: \\\\{toks[0]}\\\"))\\n    }\\n  }\\n}\\n\\ntest \\\"Jump Statement Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"goto label;\\\" : [EOF],\\n    \\\"continue;\\\" : [EOF],\\n    \\\"break;\\\" : [EOF],\\n    \\\"return;\\\" : [EOF],\\n    \\\"return 42;\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = JumpStatement::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\npub struct CompilationUnit {\\n  externalDecls: Array[ExternalDeclaration]\\n} derive(Show, Eq)\\n\\nfn CompilationUnit::parse(toks: ArrayView[Token], ctx: Context) -> CompilationUnit raise {\\n  let external_decls: Array[ExternalDeclaration] = Array::new()\\n  loop toks {\\n    [EOF] => break CompilationUnit::{ externalDecls: external_decls } // End of input\\n    toks => {\\n      let (external_decl, rest_toks) = ExternalDeclaration::parse(toks, ctx);\\n      external_decls.push(external_decl);\\n      continue rest_toks\\n    }\\n  }\\n}\\n\\ntest \\\"CompilationUnit Parsing Test\\\" {\\n  let codes = [\\n    \\\"int main() { return 0; }\\\",\\n    \\\"float compute(float x, float y) { return x * y; }\\\",\\n    \\\"typedef struct { int x; int y; } Point; Point* new(int, int);\\\"\\n  ]\\n\\n  for code in codes {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    assert_true((try? CompilationUnit::parse(toks, ctx)) is Ok(_), msg=\\\"Failed to parse code: \\\\{code}\\\")\\n  }\\n}\\n\\npub enum ExternalDeclaration {\\n  FunctionDefinition(FunctionDefinition)\\n  Declaration(Declaration)\\n} derive(Show, Eq)\\n\\nfn ExternalDeclaration::parse(toks: ArrayView[Token], ctx: Context) -> (ExternalDeclaration, ArrayView[Token]) raise {\\n  match (try? FunctionDefinition::parse(toks, ctx)) {\\n    Ok((func_def, rest_toks)) => (ExternalDeclaration::FunctionDefinition(func_def), rest_toks)\\n    Err(e) if e is FunctionDefinitionParseError::CompoundStatementParseError(ce) => {\\n      raise ce\\n    }\\n    Err(_) => {\\n      let (decl, rest) = Declaration::parse(toks, ctx);\\n      guard rest is [Semi, .. rest_toks] else {\\n        let idx = ctx.alltoks.length() - rest.length()\\n        raise ParseError((idx, \\\"Parse Error: Expected ';' after declaration\\\"))\\n      }\\n      (ExternalDeclaration::Declaration(decl), rest_toks)\\n    }\\n  }\\n}\\n\\ntest \\\"ExternalDeclaration Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"int func(int a, char *b) { return a + b; }\\\" : [EOF],\\n    \\\"void myFunc() { int x = 1, y = 0; return x * y; }\\\" : [EOF],\\n    \\\"float compute(float x, float y) { return x * y; }\\\" : [EOF],\\n    \\\"int a;\\\" : [EOF],\\n    \\\"char *str;\\\" : [EOF],\\n    \\\"typedef struct { int x; int y; } Point;\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = ExternalDeclaration::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//functionDefinition\\n//    : declarationSpecifiers declarator declarationList? compoundStatement\\n//    ;\\npub struct FunctionDefinition {\\n  declSpecs: Array[DeclSpec]\\n  declarator: Declarator\\n  kr_declarations: Array[Declaration]\\n  body: CompoundStatement\\n} derive(Show, Eq)\\n\\npub suberror FunctionDefinitionParseError {\\n  DeclaratorParseError(Error)\\n  KRDeclarationParseError(Error)\\n  CompoundStatementParseError(Error)\\n}\\n\\nfn FunctionDefinition::parse(toks: ArrayView[Token], ctx: Context) -> (FunctionDefinition, ArrayView[Token]) raise FunctionDefinitionParseError {\\n  let (decl_specs, rest_toks) = DeclSpecList::parse(toks, ctx)\\n\\n  let (declarator, rest_toks) = Declarator::parse(rest_toks, ctx) catch {\\n    err => raise FunctionDefinitionParseError::DeclaratorParseError(err)\\n  }\\n\\n  let (kr_declarations, rest_toks) = if !(rest_toks is [LBrace, ..]) {\\n    let decls: Array[Declaration] = Array::new()\\n    loop rest_toks {\\n      [LBrace, ..] as rest_toks => break (Array::new(), rest_toks) // No more kr_declarations\\n      [Semi, .. rest_toks] => {\\n        // Empty declaration, just skip it\\n        continue rest_toks\\n      }\\n      rest_toks => {\\n        let (decl, rest_toks) = Declaration::parse(rest_toks, ctx) catch {\\n          err => raise FunctionDefinitionParseError::KRDeclarationParseError(err)\\n        }\\n        decls.push(decl);\\n        continue rest_toks\\n      }\\n    }\\n  } else {\\n    (Array::new(), rest_toks) // No kr_declarations\\n  }\\n\\n  let (body, rest_toks) = CompoundStatement::parse(rest_toks, ctx) catch {\\n    err => raise FunctionDefinitionParseError::CompoundStatementParseError(err)\\n  }\\n  let function_def = FunctionDefinition::{\\n    declSpecs: decl_specs.inner(),\\n    declarator,\\n    kr_declarations,\\n    body\\n  }\\n  (function_def, rest_toks)\\n}\\n\\ntest \\\"FunctionDefinition Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"int func(int a, char *b) { return a + b; }\\\" : [EOF],\\n    \\\"void myFunc() { int x = 1, y = 0; return x * y; }\\\" : [EOF],\\n    \\\"float compute(float x, float y) { return x * y; }\\\" : [EOF],\\n    \\\"int main() { return 0; }\\\" : [EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = FunctionDefinition::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n//parameterTypeList\\n//    : parameterList (',' '...')?\\n//    ;\\npub struct ParameterTypeList {\\n  params: Array[ParameterDecl]\\n  variadic: Bool\\n} derive(Show, Eq)\\n\\nfn ParameterTypeList::parse(toks: ArrayView[Token], ctx: Context) -> (ParameterTypeList, ArrayView[Token]) raise {\\n  let (params, rest_toks) = ParameterList::parse(toks, ctx);\\n  let params = params.inner()\\n  match rest_toks {\\n    [Comma, Ellipsis, .. rest_toks] => {\\n      let param_type_list = ParameterTypeList::{ params, variadic: true }\\n      (param_type_list, rest_toks)\\n    }\\n    _ => {\\n      let param_type_list = ParameterTypeList::{ params, variadic: false }\\n      (param_type_list, rest_toks)\\n    }\\n  }\\n}\\n\\n//parameterList\\n//    : parameterDeclaration (',' parameterDeclaration)*\\n//    ;\\npriv type ParameterList Array[ParameterDecl]\\n\\nfn ParameterList::parse(toks: ArrayView[Token], ctx: Context) -> (ParameterList, ArrayView[Token]) raise {\\n  let decls: Array[ParameterDecl] = Array::new()\\n  let (first_decl, rest_toks) = ParameterDecl::parse(toks, ctx);\\n  decls.push(first_decl)\\n  let rest_toks = loop rest_toks {\\n    [Comma, .. rest_toks] => {\\n      let (next_decl, rest) = ParameterDecl::parse(rest_toks, ctx);\\n      decls.push(next_decl)\\n      continue rest\\n    }\\n    [RParen, ..] as rest_toks => {\\n      break rest_toks // End of parameter list\\n    }\\n    toks => {\\n      let idx = ctx.alltoks.length() - toks.length()\\n      raise ParseError((idx, \\\"Parse Error: Expected ',' or ')' in parameter list, current token is \\\\{toks[0]}\\\"))\\n    }\\n  }\\n  let param_list = ParameterList(decls)\\n  (param_list, rest_toks)\\n}\\n\\ntest \\\"ParameterList Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"int a, char *b, const int c, float d)\\\" : [RParen, EOF],\\n    \\\"int a, char *b)\\\" : [RParen, EOF],\\n    \\\"const int c)\\\" : [RParen, EOF],\\n    \\\"float d)\\\" : [RParen, EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = ParameterList::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\n\\n//parameterDeclaration\\n//    : declarationSpecifiers (declarator | abstractDeclarator)?\\n//    ;\\npub struct ParameterDecl {\\n  decl_specs: Array[DeclSpec]\\n  declarator: ParamDeclarator?\\n} derive(Show, Eq)\\n\\nfn ParameterDecl::parse(toks: ArrayView[Token], ctx: Context) -> (ParameterDecl, ArrayView[Token]) raise {\\n  let (decl_specs, rest_toks) = DeclSpecList::parse(toks, ctx);\\n  let decl_specs = decl_specs.inner()\\n  guard decl_specs.length() > 0 else {\\n    let idx = ctx.alltoks.length() - toks.length()\\n    raise ParseError((idx, \\\"Parse Error: Parameter declaration must have at least one declaration specifier\\\"))\\n  }\\n  let (declarator, rest_toks) = match (try? ParamDeclarator::parse(rest_toks, ctx)) {\\n    Ok((declarator, rest_toks)) => (Some(declarator), rest_toks)\\n    Err(_) => (None, rest_toks) // No declarator or abstract declarator\\n  }\\n  let param_decl = ParameterDecl::{\\n    decl_specs,\\n    declarator\\n  }\\n  (param_decl, rest_toks)\\n}\\n\\ntest \\\"ParameterDecl Parsing Test\\\" {\\n  let code_expect_rest: Map[String, ArrayView[Token]] = {\\n    \\\"int a, \\\" : [Comma, EOF],\\n    \\\"char *b ,\\\" : [Comma, EOF],\\n    \\\"const int c,\\\" : [Comma, EOF],\\n    \\\"float d)\\\" : [RParen, EOF],\\n  }\\n\\n  for code, expect_rest in code_expect_rest {\\n    let ctx = Context::create(code)\\n    ctx.tokenize()\\n    let toks = ctx.alltoks\\n    let (_, rest_toks) = ParameterDecl::parse(toks, ctx);\\n    assert_eq(rest_toks, expect_rest)\\n  }\\n}\\n\\npub enum ParamDeclarator {\\n  Declarator(Declarator)\\n  AbstractDeclarator(AbstractDeclarator)\\n} derive(Show, Eq)\\n\\nfn ParamDeclarator::parse(toks: ArrayView[Token], ctx: Context) -> (ParamDeclarator, ArrayView[Token]) raise {\\n  if (try? Declarator::parse(toks, ctx)) is Ok((declarator, rest_toks)) && rest_toks is [Comma | RParen, ..] {\\n    (ParamDeclarator::Declarator(declarator), rest_toks)\\n  } else if (try? AbstractDeclarator::parse(toks, ctx)) is Ok((abstract_declarator, rest_toks)) && rest_toks is [Comma | RParen, ..] {\\n    (ParamDeclarator::AbstractDeclarator(abstract_declarator), rest_toks)\\n  } else {\\n    let idx = ctx.alltoks.length() - toks.length()\\n    raise ParseError((idx, \\\"Parse Error: Expected declarator or abstract declarator in parameter declaration, current token is \\\\{toks[0]}\\\"))\\n  }\\n}\\n\\n// --------------------\\n\\npub fn Context::parse(self: Self) -> Unit raise {\\n  guard self.alltoks.length() > 0 else {\\n    println(\\\"Should do `tokenize` before parsing\\\")\\n    panic()\\n  }\\n\\n  let compilation_unit = CompilationUnit::parse(self.alltoks, self);\\n  for e in compilation_unit.externalDecls {\\n    self.external_decls.push(e);\\n  }\\n}\\n\",\"name\":\"read_file\",\"role\":\"tool\",\"tool_call_id\":\"toolu_vrtx_01BtgudCuWzrtDfqM1ZA94RX\"}",
      "id": "f1f488d3-b248-4bed-a25a-81d556726548",
      "role": "tool",
      "timestamp": 1754546960301
    },
    {
      "content": "{\"content\":\"现在让我看看color包的功能：\",\"role\":\"assistant\",\"tool_calls\":[{\"id\":\"toolu_vrtx_01KemJuMyoVkcJqreFdrF9D1\",\"index\":0,\"type\":\"function\",\"function\":{\"name\":\"read_file\",\"arguments\":\"{\\\"path\\\": \\\"color/print.mbt\\\"}\"}}]}",
      "id": "c915bfcd-6193-4d44-85f6-a9985029c45c",
      "role": "assistant",
      "timestamp": 1754546965771
    },
    {
      "content": "{\"content\":\"\\npub(all) enum Color {\\n  Red\\n  Yellow\\n  Magenta\\n}\\n\\npub fn taint(msg: String, color: Color) -> String {\\n  match color {\\n    Red => \\\"\\\\x1b[31m\\\\{msg}\\\\x1b[0m\\\"\\n    Yellow => \\\"\\\\x1b[33m\\\\{msg}\\\\x1b[0m\\\"\\n    Magenta => \\\"\\\\x1b[35m\\\\{msg}\\\\x1b[0m\\\"\\n  }\\n}\\n\",\"name\":\"read_file\",\"role\":\"tool\",\"tool_call_id\":\"toolu_vrtx_01KemJuMyoVkcJqreFdrF9D1\"}",
      "id": "5ad067a9-c203-4576-ab55-89ef5737b60b",
      "role": "tool",
      "timestamp": 1754546965861
    },
    {
      "content": "{\"content\":\"现在让我检查一下项目是否能正常构建：\",\"role\":\"assistant\",\"tool_calls\":[{\"id\":\"toolu_vrtx_01Vas6mmTZcWXX1rFaXTS9M3\",\"index\":0,\"type\":\"function\",\"function\":{\"name\":\"check_moonbit_project\",\"arguments\":\"{\\\"project_path\\\": \\\".\\\"}\"}}]}",
      "id": "68408c2d-c451-4d5d-92bd-2548d29c8978",
      "role": "assistant",
      "timestamp": 1754546969551
    },
    {
      "content": "{\"content\":\"MoonBit project check passed with no diagnostics found.\\n\\n=== STDERR ===\\nFinished. moon: ran 3 tasks, now up to date\\n\",\"name\":\"check_moonbit_project\",\"role\":\"tool\",\"tool_call_id\":\"toolu_vrtx_01Vas6mmTZcWXX1rFaXTS9M3\"}",
      "id": "478bf260-56c4-423d-b034-2646e527a704",
      "role": "tool",
      "timestamp": 1754546969690
    },
    {
      "content": "{\"content\":\"让我运行一下项目看看效果：\",\"role\":\"assistant\",\"tool_calls\":[{\"id\":\"toolu_vrtx_01VaZ4tFHXxDS1HBZsz3BN1L\",\"index\":0,\"type\":\"function\",\"function\":{\"name\":\"execute_command\",\"arguments\":\"{\\\"command\\\": \\\"moon run main/main.mbt\\\", \\\"timeout\\\": 10000}\"}}]}",
      "id": "571b5d48-ac3b-4b68-a7d1-1f3e39b1937e",
      "role": "assistant",
      "timestamp": 1754546973823
    },
    {
      "content": "{\"content\":\"Command executed successfully.\\n=== STDOUT ===\\n\\u001b[35m[demo:4:19] Warning:\\u001b[0m\\n3|\\n4|    printf(\\\"%d\\\\n\\\", a;\\n5|                    \\u001b[31m^ Parse Error: Expected closing parenthesis after argument expression list\\u001b[0m\\n\\n[Int, Identifier(\\\"main\\\"), LParen, RParen, LBrace, Int, Identifier(\\\"a\\\"), Comma, Identifier(\\\"b\\\"), Assign, Constant(Int(3)), Semi, Identifier(\\\"a\\\"), Assign, Identifier(\\\"fact\\\"), LParen, Identifier(\\\"b\\\"), RParen, Semi, Identifier(\\\"printf\\\"), LParen, StringLiteral(\\\"%d\\\\n\\\"), Comma, Identifier(\\\"a\\\"), Semi, Return, Constant(Int(0)), Semi, RBrace, EOF]\\n\\n=== STDERR ===\\n\",\"name\":\"execute_command\",\"role\":\"tool\",\"tool_call_id\":\"toolu_vrtx_01VaZ4tFHXxDS1HBZsz3BN1L\"}",
      "id": "eb763e8e-1feb-4407-932f-f5b644c0916d",
      "role": "tool",
      "timestamp": 1754546974203
    },
    {
      "content": "{\"content\":\"基于对项目的探索，我现在可以回答您的问题了：\",\"role\":\"assistant\",\"tool_calls\":[{\"id\":\"toolu_vrtx_01VWXzwdj76qun6szDR3F5Wx\",\"index\":0,\"type\":\"function\",\"function\":{\"name\":\"attempt_completion\",\"arguments\":\"{\\\"result\\\": \\\"当前项目是一个名为 **mbtcc** 的 MoonBit 编写的 C 编译器项目。\\\\n\\\\n## 项目概览\\\\n\\\\n**mbtcc** 是一个使用 MoonBit 编程语言开发的 C11 标准编译器，具有以下特点：\\\\n\\\\n### 主要功能\\\\n- 支持 C11 标准语法\\\\n- 词法分析（已完成 ✅）\\\\n- 语法分析（开发中）\\\\n- 错误恢复机制\\\\n- 警告系统\\\\n- 彩色输出支持\\\\n\\\\n### 项目目标\\\\n1. **验证 llvm.mbt 的功能**：作为 LLVM MoonBit 绑定的测试工具\\\\n2. **为 MoonLLVM 项目提供前端实现**：作为完整编译器工具链的一部分\\\\n3. **最终目标**：替代 MoonBit 当前使用的 tcc 编译器\\\\n\\\\n### 项目结构\\\\n- **main/**：主程序入口，演示编译器的使用\\\\n- **parser/**：核心解析模块，包含词法分析器和语法分析器\\\\n- **color/**：彩色输出工具，用于友好的错误提示\\\\n\\\\n### 当前状态\\\\n从项目的 RoadMap 可以看出：\\\\n- ✅ **词法分析**：已完成\\\\n- 🔄 **语法分析**：正在开发中（已实现大部分 C 语法结构）\\\\n- ⏳ **语义检查**：待开发\\\\n- ⏳ **预处理器**：待开发\\\\n- ⏳ **LLVM 代码生成**：待开发\\\\n\\\\n### 技术亮点\\\\n1. **完整的 C 语法支持**：包括表达式、语句、声明、函数定义等\\\\n2. **错误恢复**：能够在遇到语法错误时继续解析\\\\n3. **友好的错误提示**：带有彩色输出和位置信息\\\\n4. **模块化设计**：清晰的包结构和职责分离\\\\n\\\\n这个项目展示了使用 MoonBit 构建复杂编译器前端的可行性，为现代编译器工具链开发提供了有价值的参考实现。\\\"}\"}}]}",
      "id": "0d266e78-c333-409a-8e3d-1e36be6f1973",
      "role": "assistant",
      "timestamp": 1754546990428
    },
    {
      "content": "{\"content\":\"当前项目是一个名为 **mbtcc** 的 MoonBit 编写的 C 编译器项目。\\n\\n## 项目概览\\n\\n**mbtcc** 是一个使用 MoonBit 编程语言开发的 C11 标准编译器，具有以下特点：\\n\\n### 主要功能\\n- 支持 C11 标准语法\\n- 词法分析（已完成 ✅）\\n- 语法分析（开发中）\\n- 错误恢复机制\\n- 警告系统\\n- 彩色输出支持\\n\\n### 项目目标\\n1. **验证 llvm.mbt 的功能**：作为 LLVM MoonBit 绑定的测试工具\\n2. **为 MoonLLVM 项目提供前端实现**：作为完整编译器工具链的一部分\\n3. **最终目标**：替代 MoonBit 当前使用的 tcc 编译器\\n\\n### 项目结构\\n- **main/**：主程序入口，演示编译器的使用\\n- **parser/**：核心解析模块，包含词法分析器和语法分析器\\n- **color/**：彩色输出工具，用于友好的错误提示\\n\\n### 当前状态\\n从项目的 RoadMap 可以看出：\\n- ✅ **词法分析**：已完成\\n- 🔄 **语法分析**：正在开发中（已实现大部分 C 语法结构）\\n- ⏳ **语义检查**：待开发\\n- ⏳ **预处理器**：待开发\\n- ⏳ **LLVM 代码生成**：待开发\\n\\n### 技术亮点\\n1. **完整的 C 语法支持**：包括表达式、语句、声明、函数定义等\\n2. **错误恢复**：能够在遇到语法错误时继续解析\\n3. **友好的错误提示**：带有彩色输出和位置信息\\n4. **模块化设计**：清晰的包结构和职责分离\\n\\n这个项目展示了使用 MoonBit 构建复杂编译器前端的可行性，为现代编译器工具链开发提供了有价值的参考实现。\",\"name\":\"attempt_completion\",\"role\":\"tool\",\"tool_call_id\":\"toolu_vrtx_01VWXzwdj76qun6szDR3F5Wx\"}",
      "id": "661a3f1a-9cd9-4aa0-98df-07b1753b2e71",
      "role": "tool",
      "timestamp": 1754546990433
    }
  ],
  "name": "Session 8/7/2025, 2:08:40 PM",
  "updated_at": 1754546990433
}